buildscript {
    repositories {
        maven { url "https://plugins.gradle.org/m2/" }
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${spring_boot_version}")
    }
}

apply plugin: 'java-library'
apply plugin: 'org.springframework.boot'
apply plugin: 'io.spring.dependency-management'

version = siriusFrontendVersion

bootJar {
    enabled = false
}

jar {
    enabled = true
    archiveClassifier = ''
}
dependencies {
    //project
    implementation(project(':sirius_cli'))
    api project(':sirius-sdk')
    implementation project(':sirius-sdk:sirius-sdk.jjobs')
    //internal
    api "de.unijena.bioinf:jjobs-swing:$jjobs_version"
    //external
    implementation 'org.jdesktop:timingframework:0.55'
    api "net.sf.opencsv:opencsv:2.3"
    api "org.swinglabs.swingx:swingx-all:1.6.5-1"

    //cdk
    for (module in ["render", "renderextra", "renderawt", "data", "core", "interfaces", "inchi", "smiles", "io", "ioformats", "sdg", "smarts", "legacy", "fingerprint", "silent", "depict"])
        api "org.openscience.cdk:cdk-$module:$cdk_version"

    api 'com.glazedlists:glazedlists:1.11.0'

    api 'org.apache.xmlgraphics:batik-rasterizer:1.16'
    api 'org.apache.xmlgraphics:fop:2.7'

    implementation 'com.formdev:flatlaf:3.5.2'
    implementation 'com.formdev:flatlaf-extras:3.5.2'
    implementation 'com.github.weisj:jsvg:1.6.1'
    implementation 'raven.swing:spinner-progress:1.0.0'

    api "org.apache.commons:commons-text:$commons_text_version"

    implementation 'com.miglayout:miglayout:3.7.4'

    // jxbrowser plugin can detect the current platform and adds the corresponding Chromium binaries.
    // implementation(jxbrowser.currentPlatform)
    // We use SiriusPlatform instead to allow for cross-platform builds
    implementation "com.teamdev.jxbrowser:jxbrowser-${siriusTargetPlatform.jxClassifier().orElseThrow()}:${jxbrowser.version.get()}"

    // Adds dependency to the Swing UI toolkit integration.
    implementation(jxbrowser.swing)
}

// Define the output directory for the generated resources
def jxLicenseDirName = "jxLicense";
def generatedResourcesDir = layout.buildDirectory.dir("generated/resources/$jxLicenseDirName")

// Add the generated resources directory to the main source set
sourceSets {
    main {
        resources {
            srcDir generatedResourcesDir
        }
    }
}

// Create task to generate the properties file with the license key
tasks.register('generateJxLicenceProperties') {
    doLast {
        // Ensure the output directory exists
        def outputDir = file(generatedResourcesDir)
        outputDir.mkdirs()

        // Create the properties file
        def propertiesFile = file("$outputDir/${jxLicenseDirName}.build.properties")

        // Write the key to the file
        if (project.hasProperty('jxbrowser.license.key')) {
            // Read the key from gradle.properties. Provide a default value for safety.
            propertiesFile.text = "jxbrowser.license.key=${project.property('jxbrowser.license.key')}"
        } else {
            logger.lifecycle("\n" +
                    "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n" +
                    "!! WARNING: 'jxbrowser.license.key' is missing or empty in gradle.properties !!\n" +
                    "!! The application may not function correctly without it.                    !!\n" +
                    "!! Please add the key to your user's properties file:                        !!\n" +
                    "!! Location: ~/.gradle/gradle.properties                                     !!\n" +
                    "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n")
            propertiesFile.text = ""
        }
    }
}

// Hook the custom task into the build process
// This ensures task runs before the resources are processed.
processResources.dependsOn('generateJxLicenceProperties')