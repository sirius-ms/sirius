/*
 * SIRIUS Nightsky API
 * REST API that provides the full functionality of SIRIUS and its web services as background service. It is intended as entry-point for scripting languages and software integration SDKs.This API is exposed by SIRIUS 6
 *
 * The version of the OpenAPI document: 2.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.sirius.ms.sdk.api;

import io.sirius.ms.sdk.model.*;
import org.junit.FixMethodOrder;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.junit.runners.MethodSorters;
import org.springframework.web.reactive.function.client.WebClientResponseException;

import java.io.IOException;
import java.util.List;
import java.util.Set;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

/**
 * API tests for FeaturesApi
 */
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class FeaturesApiTest {

    private FeaturesApi instance;
    private ProjectInfo project;
    private String featureIdGet;
    private String featureIdDelete;

    @BeforeEach
    public void setUp() throws IOException {
        TestSetup.getInstance().loginIfNeeded();
        // Assume TestSetup is a utility class that initializes the API client and other test setup.
        instance = TestSetup.getInstance().getSiriusClient().features();
        project = TestSetup.getInstance().createTestProject("featureTest", TestSetup.getInstance().getProjectSourceResults());
        featureIdDelete = "595969845215149616";
        featureIdGet = "595969845215149616";
    }

    @AfterEach
    public void tearDown() {
        TestSetup.getInstance().deleteTestProject(project);
    }

    @Test
    public void testInstance() {
        assertNotNull(instance);
    }

    @Test
    public void testDeleteAlignedFeature() {
        String projectId = project.getProjectId();
        String alignedFeatureId = featureIdDelete;

        // Deleting the feature
        instance.deleteAlignedFeature(projectId, alignedFeatureId);

        // Verifying that fetching the deleted feature throws an exception
        WebClientResponseException exception = assertThrows(WebClientResponseException.class, () ->
                instance.getAlignedFeature(projectId, alignedFeatureId, false, null));

        // Asserting that the exception is a 404 (not found)
        Assertions.assertEquals(404, exception.getStatusCode().value());
    }

    @Test
    public void testGetAlignedFeatures() {
        String projectId = project.getProjectId();
        List<AlignedFeatureOptField> featureOptFields = List.of(
                AlignedFeatureOptField.TOPANNOTATIONS,
                AlignedFeatureOptField.TOPANNOTATIONSDENOVO,
                AlignedFeatureOptField.MSDATA
        );

        List<AlignedFeature> response = instance.getAlignedFeatures(projectId, false, featureOptFields);

        assertNotNull(response);
        assertTrue(!response.isEmpty() && response.size() <= 2);
    }

    @Test
    public void testGetAlignedFeature() {
        String projectId = project.getProjectId();
        List<AlignedFeature> features = instance.getAlignedFeatures(projectId, false, null);
        String alignedFeatureId = features.getFirst().getAlignedFeatureId();

        AlignedFeature response = instance.getAlignedFeature(projectId, alignedFeatureId, false, null);

        assertNotNull(response);
        Assertions.assertEquals("595969845215149616", response.getAlignedFeatureId());
    }

    @Test
    public void testGetFormulaCandidate() {
        String projectId = project.getProjectId();
        List<AlignedFeature> features = instance.getAlignedFeatures(projectId, false, null);
        String alignedFeatureId = features.getFirst().getAlignedFeatureId();
        String formulaId = "595969889171455582";

        FormulaCandidate response = instance.getFormulaCandidate(projectId, alignedFeatureId, formulaId, false, null);

        assertNotNull(response);
        Assertions.assertEquals(formulaId, response.getFormulaId());
    }

    @Test
    public void testGetFormulaCandidates() {
        String projectId = project.getProjectId();
        String alignedFeatureId = featureIdGet;

        List<FormulaCandidate> response = instance.getFormulaCandidates(projectId, alignedFeatureId, false, null);

        assertNotNull(response);
        assertEquals(1, response.size());
    }

    @Test
    public void testGetStructureCandidates() {
        String projectId = project.getProjectId();
        String alignedFeatureId = featureIdGet;
        List<StructureCandidateOptField> structureCandidateOptField = List.of(
                StructureCandidateOptField.FINGERPRINT,
                StructureCandidateOptField.DBLINKS,
                StructureCandidateOptField.LIBRARYMATCHES,
                StructureCandidateOptField.STRUCTURESVG
        );

        List<StructureCandidateFormula> response = instance.getStructureCandidates(projectId, alignedFeatureId, structureCandidateOptField);

        assertNotNull(response);
        assertEquals(61, response.size());
        response.forEach(candidate -> assertNotNull(candidate.getStructureSvg()));
        response.forEach(candidate -> assertNotNull(candidate.getDbLinks()));
        response.forEach(candidate -> assertNotNull(candidate.getFingerprint()));
    }

    @Test
    public void testGetStructureCandidatesByFormula() {
        String projectId = project.getProjectId();
        String alignedFeatureId = featureIdGet;
        String formulaId = "595969889171455582";

        List<StructureCandidateScored> response = instance.getStructureCandidatesByFormula(projectId, alignedFeatureId, formulaId, null);

        assertNotNull(response);
        assertEquals(61, response.size());
    }

    private static Stream<Arguments> validAdductProvider() {
        return Stream.of(
                // Standard valid adducts
                Arguments.of("[M+H]+", "[M+H]+", true),
                Arguments.of("[M+Na]+", "[M+Na]+", true),
                Arguments.of("[M+K]+", "[M+K]+", true),
                Arguments.of("[M+NH4]+", "[M+H3N+H]+", true),
                Arguments.of("[M+NH3+H]+", "[M+H3N+H]+", true),
                Arguments.of("[M+H3N+H]+", "[M+H3N+H]+", true),
                Arguments.of("[2M+H]+", "[2M+H]+", true),
                Arguments.of("[M+2H2O+H]+", "[M+H4O2+H]+", true),  // multiplier before adduct

                // Invalid correctable syntax
                Arguments.of("M+H+", "[M+H]+", true),  // Missing brackets
                Arguments.of("[M+H]", "[M+H]+", true) , // Missing charge
                Arguments.of("(M+H)+", "[M+H]+", true) , // Invalid parentheses charge
                Arguments.of("[M++H]+", "[M+H]+", true), // Invalid double plus
                Arguments.of("[M+2(H2O)+H]+","[M+H4O2+H]+", true),  // multiplier before adduct with wrong backets
                Arguments.of("[M+H]++", "[M+H]+", true), // Invalid charge format
                Arguments.of("          ", null, true), // Empty string
                Arguments.of("", null, true), // Empty string
                //todo they should fail in future but are currently not failing
                Arguments.of("[M+X+H]+", "[M+H]+", true), // Invalid element

                // Invalid syntax adducts
                Arguments.of("[M+H]+2", null, false), // Invalid isotope peak
                Arguments.of("[M-H]-", null, false), //charge missmatch -> feature is pos
                Arguments.of("[M+H]2+", null, false) // Invalid double charged

        );
    }

    @ParameterizedTest
    @MethodSource("validAdductProvider")
    public void testFeatureWithDifferentAdducts(String adduct, String expectedResult, boolean shouldSucceed) {
        // Get base feature from TestSetup
        FeatureImport feature = TestSetup.makeProtonatedValium();

        // Modify the adduct
        feature.setDetectedAdducts(Set.of(adduct));

        // Test successful import
        List<AlignedFeature> importedFeatures = instance.addAlignedFeatures(project.getProjectId(), List.of(feature), null, null);
        assertNotNull(importedFeatures);
        if (shouldSucceed) {
            assertEquals(1, importedFeatures.size());
            // Verify the imported feature
            if (expectedResult != null)
                assertEquals(expectedResult, importedFeatures.getFirst().getDetectedAdducts().iterator().next().replaceAll("\\s+",""));
            else
                assertTrue(importedFeatures.getFirst().getDetectedAdducts().isEmpty());
        } else {
            // Test failure cases
            assertEquals(0, importedFeatures.size());
        }
    }

//    @Test
//    public void testMultipleAdductsOnSameFeature() throws IOException {
//        FeatureImport feature = TestSetup.makeProtonatedValium();
//        feature.setDetectedAdducts(Set.of("[M+H]+", "[M+Na]+"));
//
//        // This should fail as a feature can only have one adduct
//        WebClientResponseException exception = assertThrows(
//                WebClientResponseException.class,
//                () -> instance.addAlignedFeatures(project.getProjectId(), List.of(feature))
//        );
//        assertEquals(400, exception.getStatusCode().value());
//    }
//
//    @Test
//    public void testFeatureWithNoAdducts() throws IOException {
//        FeatureImport feature = TestSetup.makeProtonatedValium();
//        feature.setDetectedAdducts(null);
//
//        // Should succeed as adducts are optional
//        List<String> importedFeatureIds = instance.addAlignedFeatures(project.getProjectId(), List.of(feature));
//        assertNotNull(importedFeatureIds);
//        assertEquals(1, importedFeatureIds.size());
//    }

}
