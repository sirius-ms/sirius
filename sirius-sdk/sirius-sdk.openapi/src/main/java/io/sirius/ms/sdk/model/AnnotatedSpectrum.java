/*
 *  This file is part of the SIRIUS libraries for analyzing MS and MS/MS data
 *
 *  Copyright (C) 2024 Bright Giant GmbH
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with SIRIUS.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 *  https://openapi-generator.tech
 *  Do not edit the class manually.
 */


package io.sirius.ms.sdk.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.sirius.ms.sdk.model.AnnotatedPeak;
import io.sirius.ms.sdk.model.SimplePeak;
import io.sirius.ms.sdk.model.SpectrumAnnotation;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * Spectrum model with peak annotations based on the fragmentation tree and Epimetheus substructure annotations.  Molecular formula and adduct of the spectrum are identical to the ones of the corresponding molecular formula candidate and FragmentationTree.  Fragment molecular formulas and adducts correspond to the FragmentationTree&#39;s FragmentNodes
 */
@JsonPropertyOrder({
  AnnotatedSpectrum.JSON_PROPERTY_NAME,
  AnnotatedSpectrum.JSON_PROPERTY_MS_LEVEL,
  AnnotatedSpectrum.JSON_PROPERTY_COLLISION_ENERGY,
  AnnotatedSpectrum.JSON_PROPERTY_INSTRUMENT,
  AnnotatedSpectrum.JSON_PROPERTY_PRECURSOR_MZ,
  AnnotatedSpectrum.JSON_PROPERTY_SCAN_NUMBER,
  AnnotatedSpectrum.JSON_PROPERTY_COSINE_QUERY,
  AnnotatedSpectrum.JSON_PROPERTY_PRECURSOR_PEAK,
  AnnotatedSpectrum.JSON_PROPERTY_PEAKS,
  AnnotatedSpectrum.JSON_PROPERTY_ABS_INTENSITY_FACTOR,
  AnnotatedSpectrum.JSON_PROPERTY_SPECTRUM_ANNOTATION
})
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.6.0")
public class AnnotatedSpectrum {
  public static final String JSON_PROPERTY_NAME = "name";
  private String name;

  public static final String JSON_PROPERTY_MS_LEVEL = "msLevel";
  private Integer msLevel;

  public static final String JSON_PROPERTY_COLLISION_ENERGY = "collisionEnergy";
  private String collisionEnergy;

  public static final String JSON_PROPERTY_INSTRUMENT = "instrument";
  private String instrument;

  public static final String JSON_PROPERTY_PRECURSOR_MZ = "precursorMz";
  private Double precursorMz;

  public static final String JSON_PROPERTY_SCAN_NUMBER = "scanNumber";
  private Integer scanNumber;

  public static final String JSON_PROPERTY_COSINE_QUERY = "cosineQuery";
  private Boolean cosineQuery = false;

  public static final String JSON_PROPERTY_PRECURSOR_PEAK = "precursorPeak";
  private SimplePeak precursorPeak;

  public static final String JSON_PROPERTY_PEAKS = "peaks";
  private List<AnnotatedPeak> peaks = new ArrayList<>();

  public static final String JSON_PROPERTY_ABS_INTENSITY_FACTOR = "absIntensityFactor";
  private Double absIntensityFactor;

  public static final String JSON_PROPERTY_SPECTRUM_ANNOTATION = "spectrumAnnotation";
  private SpectrumAnnotation spectrumAnnotation;

  public AnnotatedSpectrum() {
  }

  public AnnotatedSpectrum name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * Optional Displayable name of this spectrum.
   * @return name
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getName() {
    return name;
  }


  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setName(String name) {
    this.name = name;
  }

  public AnnotatedSpectrum msLevel(Integer msLevel) {
    
    this.msLevel = msLevel;
    return this;
  }

   /**
   * MS level of the measured spectrum.  Artificial spectra with no msLevel (e.g. Simulated Isotope patterns) use null or zero
   * @return msLevel
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_MS_LEVEL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getMsLevel() {
    return msLevel;
  }


  @JsonProperty(JSON_PROPERTY_MS_LEVEL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setMsLevel(Integer msLevel) {
    this.msLevel = msLevel;
  }

  public AnnotatedSpectrum collisionEnergy(String collisionEnergy) {
    
    this.collisionEnergy = collisionEnergy;
    return this;
  }

   /**
   * Collision energy used for MS/MS spectra  Null for spectra where collision energy is not applicable
   * @return collisionEnergy
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_COLLISION_ENERGY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getCollisionEnergy() {
    return collisionEnergy;
  }


  @JsonProperty(JSON_PROPERTY_COLLISION_ENERGY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCollisionEnergy(String collisionEnergy) {
    this.collisionEnergy = collisionEnergy;
  }

  public AnnotatedSpectrum instrument(String instrument) {
    
    this.instrument = instrument;
    return this;
  }

   /**
   * Instrument information.
   * @return instrument
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_INSTRUMENT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getInstrument() {
    return instrument;
  }


  @JsonProperty(JSON_PROPERTY_INSTRUMENT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setInstrument(String instrument) {
    this.instrument = instrument;
  }

  public AnnotatedSpectrum precursorMz(Double precursorMz) {
    
    this.precursorMz = precursorMz;
    return this;
  }

   /**
   * Precursor m/z of the MS/MS spectrum  Null for spectra where precursor m/z is not applicable
   * @return precursorMz
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PRECURSOR_MZ)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Double getPrecursorMz() {
    return precursorMz;
  }


  @JsonProperty(JSON_PROPERTY_PRECURSOR_MZ)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPrecursorMz(Double precursorMz) {
    this.precursorMz = precursorMz;
  }

  public AnnotatedSpectrum scanNumber(Integer scanNumber) {
    
    this.scanNumber = scanNumber;
    return this;
  }

   /**
   * Scan number of the spectrum.  Might be null for artificial spectra with no scan number (e.g. Simulated Isotope patterns or merged spectra)
   * @return scanNumber
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_SCAN_NUMBER)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getScanNumber() {
    return scanNumber;
  }


  @JsonProperty(JSON_PROPERTY_SCAN_NUMBER)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setScanNumber(Integer scanNumber) {
    this.scanNumber = scanNumber;
  }

  public AnnotatedSpectrum cosineQuery(Boolean cosineQuery) {
    
    this.cosineQuery = cosineQuery;
    return this;
  }

   /**
   * True if spectrum is in cosine query normalized format.  Such spectrum is compatible with SpectralLibraryMatch peak assignments to reference spectra.
   * @return cosineQuery
  **/
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_COSINE_QUERY)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Boolean isCosineQuery() {
    return cosineQuery;
  }


  @JsonProperty(JSON_PROPERTY_COSINE_QUERY)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCosineQuery(Boolean cosineQuery) {
    this.cosineQuery = cosineQuery;
  }

  public AnnotatedSpectrum precursorPeak(SimplePeak precursorPeak) {
    
    this.precursorPeak = precursorPeak;
    return this;
  }

   /**
   * Get precursorPeak
   * @return precursorPeak
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PRECURSOR_PEAK)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public SimplePeak getPrecursorPeak() {
    return precursorPeak;
  }


  @JsonProperty(JSON_PROPERTY_PRECURSOR_PEAK)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPrecursorPeak(SimplePeak precursorPeak) {
    this.precursorPeak = precursorPeak;
  }

  public AnnotatedSpectrum peaks(List<AnnotatedPeak> peaks) {
    
    this.peaks = peaks;
    return this;
  }

  public AnnotatedSpectrum addPeaksItem(AnnotatedPeak peaksItem) {
    if (this.peaks == null) {
      this.peaks = new ArrayList<>();
    }
    this.peaks.add(peaksItem);
    return this;
  }

   /**
   * The peaks of this spectrum which might contain additional annotations such as molecular formulas.
   * @return peaks
  **/
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_PEAKS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public List<AnnotatedPeak> getPeaks() {
    return peaks;
  }


  @JsonProperty(JSON_PROPERTY_PEAKS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setPeaks(List<AnnotatedPeak> peaks) {
    this.peaks = peaks;
  }

  public AnnotatedSpectrum absIntensityFactor(Double absIntensityFactor) {
    
    this.absIntensityFactor = absIntensityFactor;
    return this;
  }

   /**
   * Factor to convert relative intensities to absolute intensities.  Might be null or 1 for spectra where absolute intensities are not available (E.g. artificial or merged spectra)
   * @return absIntensityFactor
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ABS_INTENSITY_FACTOR)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Double getAbsIntensityFactor() {
    return absIntensityFactor;
  }


  @JsonProperty(JSON_PROPERTY_ABS_INTENSITY_FACTOR)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAbsIntensityFactor(Double absIntensityFactor) {
    this.absIntensityFactor = absIntensityFactor;
  }

  public AnnotatedSpectrum spectrumAnnotation(SpectrumAnnotation spectrumAnnotation) {
    
    this.spectrumAnnotation = spectrumAnnotation;
    return this;
  }

   /**
   * Get spectrumAnnotation
   * @return spectrumAnnotation
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_SPECTRUM_ANNOTATION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public SpectrumAnnotation getSpectrumAnnotation() {
    return spectrumAnnotation;
  }


  @JsonProperty(JSON_PROPERTY_SPECTRUM_ANNOTATION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSpectrumAnnotation(SpectrumAnnotation spectrumAnnotation) {
    this.spectrumAnnotation = spectrumAnnotation;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AnnotatedSpectrum annotatedSpectrum = (AnnotatedSpectrum) o;
    return Objects.equals(this.name, annotatedSpectrum.name) &&
        Objects.equals(this.msLevel, annotatedSpectrum.msLevel) &&
        Objects.equals(this.collisionEnergy, annotatedSpectrum.collisionEnergy) &&
        Objects.equals(this.instrument, annotatedSpectrum.instrument) &&
        Objects.equals(this.precursorMz, annotatedSpectrum.precursorMz) &&
        Objects.equals(this.scanNumber, annotatedSpectrum.scanNumber) &&
        Objects.equals(this.cosineQuery, annotatedSpectrum.cosineQuery) &&
        Objects.equals(this.precursorPeak, annotatedSpectrum.precursorPeak) &&
        Objects.equals(this.peaks, annotatedSpectrum.peaks) &&
        Objects.equals(this.absIntensityFactor, annotatedSpectrum.absIntensityFactor) &&
        Objects.equals(this.spectrumAnnotation, annotatedSpectrum.spectrumAnnotation);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, msLevel, collisionEnergy, instrument, precursorMz, scanNumber, cosineQuery, precursorPeak, peaks, absIntensityFactor, spectrumAnnotation);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AnnotatedSpectrum {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    msLevel: ").append(toIndentedString(msLevel)).append("\n");
    sb.append("    collisionEnergy: ").append(toIndentedString(collisionEnergy)).append("\n");
    sb.append("    instrument: ").append(toIndentedString(instrument)).append("\n");
    sb.append("    precursorMz: ").append(toIndentedString(precursorMz)).append("\n");
    sb.append("    scanNumber: ").append(toIndentedString(scanNumber)).append("\n");
    sb.append("    cosineQuery: ").append(toIndentedString(cosineQuery)).append("\n");
    sb.append("    precursorPeak: ").append(toIndentedString(precursorPeak)).append("\n");
    sb.append("    peaks: ").append(toIndentedString(peaks)).append("\n");
    sb.append("    absIntensityFactor: ").append(toIndentedString(absIntensityFactor)).append("\n");
    sb.append("    spectrumAnnotation: ").append(toIndentedString(spectrumAnnotation)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

