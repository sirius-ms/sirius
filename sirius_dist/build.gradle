import org.gradle.crypto.checksum.Checksum
import org.gradle.nativeplatform.platform.internal.DefaultNativePlatform
import java.nio.file.*
import java.util.stream.Collectors

plugins {
    id 'edu.sc.seis.launch4j' version '2.5.4'
    id 'org.gradle.crypto.checksum' version '1.4.0'
}

dependencies {
    implementation "org.junit.jupiter:junit-jupiter:$junit_version"
}

version = siriusFrontendVersion

ext {
    siriusJvmArgs = ['-Xms2G',
                     '-XX:MaxRAMPercentage=60',
                     '-XX:+UseStringDeduplication',
//                     '-XX:+UseG1GC',
//                     '-XX:+UseZGC',
//                     '-XX:+ZGenerational',
                     '-XX:+ExitOnOutOfMemoryError']
    OS = DefaultNativePlatform.currentOperatingSystem

    if (siriusTargetPlatform.isLinux()) {
        osName = siriusTargetPlatform == SiriusPlatform.LINUX_x86_64 ? 'linux-x64' : 'linux-arm64'
        installerNameType = 'deb'
        installerAppendix = "_${version}-1_${siriusTargetPlatform == SiriusPlatform.LINUX_x86_64 ? 'amd64' : 'arm64'}.$installerNameType"
    } else if (siriusTargetPlatform.isWin()) {
        osName = siriusTargetPlatform == SiriusPlatform.WIN_x86_64 ? 'win-x64' : 'win-arm64'
        installerNameType = 'msi'
        installerAppendix = "-${version.replace('-SNAPSHOT', '')}.$installerNameType".toString()
    } else if (siriusTargetPlatform.isMac()) {
        osName = siriusTargetPlatform == SiriusPlatform.MAC_x86_64 ? 'macos-x64' : 'macos-arm64'
        installerNameType = 'pkg'
        installerAppendix = "-${version.replace('-SNAPSHOT', '')}.$installerNameType".toString()
    }

    // configure infos for bundled JRE
    jre_version = '21.0.6'
    jre_major = jre_version.split("[.]")[0]

    // liberica config
    jre_distributor_version = 'b631.42'
    jre_mac_prefix = null
    jre_fname = "jbr_jcef-${jre_version}-${siriusTargetPlatform.jbrClassifier().get()}-${jre_distributor_version}.tar.gz"
    jre_download_link = "https://cache-redirector.jetbrains.com/intellij-jbr/"
}

tasks.register('downloadRuntimeImage', Download) {
    group = "runtime"
    src "${jre_download_link}${jre_fname}"
    dest getBuildDir().toPath().resolve('runtime').resolve("$jre_fname").toFile()
    onlyIfModified true
    overwrite false
}

tasks.register('extractRuntimeImage', ExtractRuntime) {
    dependsOn downloadRuntimeImage
    inputArchive = downloadRuntimeImage.dest
    outputDir = file(downloadRuntimeImage.dest.absolutePath.replace('.zip', '').replace('.tar.gz', ''))
}

subprojects {
    apply plugin: 'application'
    apply plugin: 'edu.sc.seis.launch4j'
    ext {
        // jpackage based distribution output dir
        jpDistDir = getLayout().getBuildDirectory().file("jpDists")
    }
    jar {
        enabled = false
    }
    //remove dependencies that should not be in build
    configurations.each { conf ->
        SiriusPlatform.allBut(siriusTargetPlatform).stream()
                .map { it.inchiClassifier() }.flatMap { it.stream() }
                .forEach { conf.exclude(group: "io.github.dan2097", module: "jna-inchi-$it") }
        if (excludeCbcNative)
            conf.exclude(group: "de.unijena.bioinf.cbc-java", module: "cbc-java-native")

        //remove commercial solver -> given at runtime
        conf.exclude group: "com.gurobi", module: "gurobi-jar"
        conf.exclude group: "cplex", module: "cplex"
    }

    //###################################### Start Default values ##########################################

    //collect auto generated profiles and check them for null values
    tasks.register('collectProfiles') {
        group = 'properties'
        outputs.dir("$buildDir/tmp/profiles/de.unijena.bioinf.ms.defaults")
        doLast {
            outputs.files.singleFile.deleteDir()
            copy {
                from configurations.runtime.resolve().stream().map { f ->
                    zipTree(f).matching {
                        include 'de.unijena.bioinf.ms.defaults/*.auto.config'
                    }
                }.collect(Collectors.toList())

                into "$buildDir/tmp/profiles"
            }
        }


    }
    collectProfiles.dependsOn('compileJava')

    tasks.register('makeProfileTemplate') {
        group = 'properties'
        outputs.file("$buildDir/tmp/profiles_concat/concat.profile")
        doLast {
            outputs.files.singleFile.deleteDir()
            outputs.files.singleFile.withWriter { w ->
                // For each input file path
                tasks.collectProfiles.outputs.files.singleFile.listFiles().each { f ->
                    // Get a reader for the input file
                    f.withReader { r ->
                        // And write data from the input into the output
                        w << r << '\n'
                    }
                }
            }
        }
    }
    makeProfileTemplate.dependsOn('collectProfiles')

    tasks.register('checkDefaultProfile') {
        group = 'properties'
        doLast {
            Properties defaultProfile = new Properties()
            tasks.makeProfileTemplate.outputs.files.singleFile
                    .withReader("UTF8", {
                        defaultProfile.load(it)
                    })

            def errorCount = 0
            logger.lifecycle(System.lineSeparator() + "Checking for NULL values in Profile...")
            defaultProfile.keys().each { e ->
                def v = defaultProfile.getProperty(e)
                if (v == null || ((String) v).isEmpty()) {
                    logger.warn("${e} is NULL!")
                    errorCount++
                }
            }
            if (errorCount > 0) {
                logger.error("FAILED: $errorCount NULL values found!" + System.lineSeparator())
                throw new GradleException("Error: There are NULL values in at least one auto.config files. See Warnings for more detailed information")
            }
            logger.lifecycle("DONE: No NULL values found!" + System.lineSeparator())
        }
    }
    checkDefaultProfile.dependsOn('makeProfileTemplate')

    //###################################### END Default values ##########################################
    launch4j {
        copyright = "Chair of Bioinformatics, Friedrich-Schiller-University Jena."
        companyName = "Bright Giant GmbH"

        version = siriusFrontendVersion.toString().replace("-SNAPSHOT", "")
        textVersion = siriusFrontendVersion
        supportUrl = "https://github.com/sirius-ms/sirius/"
        fileDescription = "SIRIUS command-line interface"

        icon = "${rootProject.projectDir}/icons/sirius-icon.ico"
        headerType = "console"
        outfile = "sirius.exe"

        jvmOptions = project.siriusJvmArgs + [
                '-Djava.library.path=.\\'
        ]

        dontWrapJar = true
        classpath = [(libDir == null ? "app" : libDir) + "\\*", "%GUROBI_HOME%\\lib\\gurobi.jar", "%CPLEX_HOME%\\lib\\cplex.jar"]
        libraryDir = libDir == null ? "app" : libDir

        jdkPreference = "preferJdk"
        jreMinVersion = null
        jreMaxVersion = null
        bundledJre64Bit = true
        jreRuntimeBits = "64"
        messagesBundledJreError = "Could not Load bundled JRE."
        bundledJrePath = launch4jJDKPath != null ? launch4jJDKPath : ".\\runtime"
    }

    tasks.register('distImage', AppImage) {
        enabled = false
        if (siriusTargetPlatform.isWin())
            dependsOn createAllExecutables

        jpackagerBin = Paths.get(System.getProperty("java.home")).resolve('bin').resolve(OS.isWindows() ? 'jpackage.exe' : 'jpackage').toFile()
        mainClass = mainClassName
        outputDir = jpDistDir.get().getAsFile()
        winConsole = true


        doLast {
            if (!includeRuntime)
                throw new IllegalArgumentException("OS specific App images need to include java runtime. Please run with `-P build.sirius.starter.jdk.include=true`")
            File appRootTarget
            File launcherTarget
            File runtimeTarget
            File resourceTarget
            if (siriusTargetPlatform.isLinux()) {
                appRootTarget = outputDir.toPath().resolve(imageName).toFile()
                launcherTarget = appRootTarget.toPath().resolve("bin").toFile()
                runtimeTarget = appRootTarget.toPath().resolve("lib/runtime").toFile()
                resourceTarget = appRootTarget
            } else if (siriusTargetPlatform.isWin()) {
                appRootTarget = outputDir.toPath().resolve(imageName).toFile()
                launcherTarget = appRootTarget
                runtimeTarget = appRootTarget.toPath().resolve("runtime").toFile()
                resourceTarget = appRootTarget
            } else if (siriusTargetPlatform.isMac()) {
                appRootTarget = outputDir.toPath().resolve("${imageName}.app/Contents").toFile()
                launcherTarget = appRootTarget.toPath().resolve("MacOS").toFile()
                runtimeTarget = appRootTarget.toPath().resolve("runtime").toFile()
                resourceTarget = appRootTarget.toPath().resolve("Resources").toFile()

            } else {
                throw new RuntimeException("Could not detect OS for packaging!")
            }

            copy {
                //this also loads lic tester
                from(inputDir.getParentFile()) {
                    exclude "app/**"
                    exclude "lib/**"
                    exclude "bin/**"
                    exclude "runtime/**"
                    exclude "*.bat"
                    exclude "*.exe"
                }
                into(resourceTarget)
                includeEmptyDirs = false
            }

            if (!includeRuntime)
                delete runtimeTarget

            if (siriusTargetPlatform.isWin()) {
                //delete exes because they are write protected an cannot be ovewritten
                delete fileTree(dir: launcherTarget, include: "*.exe")
                copy {
                    from("${buildDir}/launch4j") {
                        include("*.exe")
                    }
                    into(appRootTarget)
                }
            } else if (siriusTargetPlatform.isLinux()) {
                delete appRootTarget.toPath().resolve("lib/libapplauncher.so").toFile()
            }

            def templateBinding = [
                    toolName : "SIRIUS",
                    mainClass: mainClassName
            ]

            def f
            def sf
            if (siriusTargetPlatform.isLinux()) {
                f = file("$appRootTarget/bin/sirius")
                sf = file("${rootDir}/scripts/sirius.sh.templ")
                templateBinding.shell = "sh"
                templateBinding.classPath = "\\\"\$JAR_HOME/*\\\":\\\"\$GUROBI_HOME/lib/gurobi.jar\\\":\\\"\$CPLEX_HOME/lib/cplex.jar\\\""
                templateBinding.javaLibPath = ""//includeRuntime ? "\$APP_HOME/lib/runtime/lib" : ""
                templateBinding.gurobiHome = "/lib"
                templateBinding.cplexHome = "/bin/x86-64_linux"
                templateBinding.jvmOpts = "${Arrays.stream(jvmArgs).collect(Collectors.joining(' '))}"
                templateBinding.javaCommand = "\$APP_HOME/lib/runtime/bin/java"
                templateBinding.jarHome = libDir == null ? "\$APP_HOME/lib/app" : libDir
            } else if (siriusTargetPlatform.isMac()) {
                f = file("$appRootTarget/MacOS/sirius")
                sf = file("${rootDir}/scripts/sirius.sh.templ")
                templateBinding.shell = "zsh"
                templateBinding.classPath = "\\\"\$JAR_HOME/*\\\":\\\"\$GUROBI_HOME/lib/gurobi.jar\\\":\\\"\$CPLEX_HOME/lib/cplex.jar\\\""
                templateBinding.javaLibPath = ""//includeRuntime ? "\$APP_HOME/runtime/Contents/Home/lib" : ""
                templateBinding.gurobiHome = "/lib"
                templateBinding.cplexHome = "/bin/x86-64_osx"
                templateBinding.jvmOpts = "${Arrays.stream(jvmArgs).collect(Collectors.joining(' '))}"
                templateBinding.javaCommand = "\$APP_HOME/runtime/Contents/Home/bin/java"
                templateBinding.jarHome = libDir == null ? "\$APP_HOME/app" : libDir
            } else if (siriusTargetPlatform.isWin()) {
                f = file("$appRootTarget/sirius.bat")
                sf = file("${rootDir}/scripts/sirius.bat.templ")
                templateBinding.classPath = "%JAR_HOME%\\*"
                templateBinding.jvmOpts = "${Arrays.stream(jvmArgs).map({ s -> '"' + s + '"' }).collect(Collectors.joining(" "))}"
                templateBinding.jarHome = libDir == null ? "%APP_HOME%\\app" : libDir
                templateBinding.gurobiJar = "%GUROBI_HOME%\\lib\\gurobi.jar"
                templateBinding.cplexJar = "%CPLEX_HOME%\\lib\\cplex.jar"
            } else {
                throw new IllegalArgumentException("Cannot determine operating system for build")
            }
            String script = sf.text
            templateBinding.forEach({ k, v -> script = script.replace("#$k#", v) })
            f.withWriter { it.write(script) }
            f.setExecutable(true, false)

            println("----> DistImage")
            appRootTarget.list().each { println it }
            println()
            println("----> DistImage bin")
            launcherTarget.list().each { println it }
            println()
            println("----> DistImage lib")
            new File(appRootTarget, 'lib').list().each { println it }
            println()
            println("----> DistImage runtime")
            runtimeTarget.list().each { println it }

        }
    }

    tasks.register('signDistImage') {
        group 'jpDist'
        dependsOn distImage

        inputs.dir(distImage.outputDir)
        doLast {
            if (siriusTargetPlatform.isMac()) {
                def signID = project.findProperty("de.unijena.bioinf.build.MACOS_APP_IDENTITY_ID")
                if (signID != null && !signID.isBlank()) {
                    getLogger().lifecycle("")
                    getLogger().lifecycle("")
                    getLogger().lifecycle("Signing with ID: " + signID)
                    def entitlementsFile = getRootProject().getProjectDir().toPath().resolve("dist").resolve("macos.entitlements").toFile()

                    def siriusBootJarName = getRootProject().getChildProjects().get('sirius_rest_service').tasks.getByName('bootJar').outputs.files.singleFile.getName();
                    def bootJar = distImage.getImageDir().toPath().resolve("Contents").resolve("app").resolve(siriusBootJarName).toAbsolutePath()
                    getLogger().lifecycle("Boot Jar Path: " + bootJar)
//                    def bootJar = Path.of("/home/fleisch/Downloads/sirius-6.0.4-SNAPSHOT-osx64/sirius.app/Contents/app/sirius_rest_service-6.0.4-SNAPSHOT-boot.jar").toAbsolutePath()

                    def extractedJars = getBuildDir().toPath().resolve("tmp").resolve("jars")
                    def extractedLibs = getBuildDir().toPath().resolve("tmp").resolve("jarLibs")
                    Files.createDirectories(extractedJars)
                    Files.createDirectories(extractedLibs)
                    try (def bootJarFs = FileSystems.newFileSystem(bootJar, Map.of("compressionMethod", "STORED"))) {
                        for (def inJar : Files.list(bootJarFs.getPath("/BOOT-INF/lib/")).toList()) {

                            Path copiedInJar = extractedJars.resolve(inJar.getFileName().toString())
                            Files.copy(inJar, copiedInJar)

                            try (def copiedInJarFs = FileSystems.newFileSystem(copiedInJar, [:])) {
                                Files.walk(copiedInJarFs.getPath("/"))
                                        .filter { inLib -> inLib.toString().toLowerCase().endsWith(".dylib") || inLib.toString().toLowerCase().endsWith(".jnilib") }
                                        .forEach { inLib ->
                                            Path copiedInLib = extractedLibs.resolve(inLib.getFileName().toString())
                                            Files.copy(inLib, copiedInLib)
//                                            getLogger().lifecycle("Remove (old) signatures from native lib '${copiedInLib.toFile().getAbsolutePath()}'")
//                                            project.exec {
//                                                commandLine(["codesign", "--remove-signature", "${copiedInLib.toFile().getAbsolutePath()}"])
//                                            }
                                            getLogger().lifecycle("  (Re-)Signing lib: " + inLib.getFileName().toString())
                                            project.exec {
                                                commandLine(["codesign", "-s", "${signID}", "--options", "runtime", "--entitlements", "${entitlementsFile.getAbsolutePath()}", "-f", "-v",
                                                             "${copiedInLib.toFile().getAbsolutePath()}"])
                                            }
                                            Files.copy(copiedInLib, inLib, StandardCopyOption.REPLACE_EXISTING)
                                            Files.delete(copiedInLib)
                                        }
                            }
//                            getLogger().lifecycle("Remove (old) signatures from nested jars '${copiedInJar.toFile().getAbsolutePath()}'")
//                            project.exec {
//                                commandLine(["codesign", "--remove-signature", "${copiedInJar.toFile().getAbsolutePath()}"])
//                            }
                            getLogger().lifecycle("Signing nested jars: " + inJar.getFileName().toString())
                            project.exec {
                                commandLine(["codesign", "--timestamp", "-s", "${signID}", "--options", "runtime", "--entitlements", "${entitlementsFile.getAbsolutePath()}", "-f", "-v",
                                             "${copiedInJar.toFile().getAbsolutePath()}"])
                            }
                            Files.copy(copiedInJar, inJar, StandardCopyOption.REPLACE_EXISTING)
                            Files.delete(copiedInJar)
                        }
                    }
                    getLogger().lifecycle("")
                    getLogger().lifecycle("Signing boot jar: " + bootJar.getFileName().toString())
                    project.exec {
                        commandLine(["codesign", "--timestamp", "-s", "${signID}", "--options", "runtime", "--entitlements", "${entitlementsFile.getAbsolutePath()}", "-f", "-v",
                                     "${bootJar.toFile().getAbsolutePath()}"])
                    }

                    getLogger().lifecycle("")
                    getLogger().lifecycle("Signing .app dir: ${distImage.getImageDir().getAbsolutePath()}")
                    project.exec {
                        commandLine(["codesign", "--timestamp", "-s", "${signID}", "--options", "runtime", "--entitlements", "${entitlementsFile.getAbsolutePath()}", "-f", "-v",
                                     "${distImage.getImageDir()}"])
                    }
                } else {
                    println "Could not find ID for signing. APP image will not be signed!"
                }
            } else if (siriusTargetPlatform.isWin()) {
                println "Image signing not needed on Windows"
            } else if (siriusTargetPlatform.isLinux()) {
                println "Image signing not yet implemented for Linux"
            }
        }
    }

    tasks.register('distImageZip') {
        group 'jpDist'
        dependsOn distImage
        doFirst {
            def imageDir = distImage.getImageDir()
            def parentPath = imageDir.parentFile.toPath()
            def zipFileName = "${distImage.imageName}-${project.version}-${project.osName}.zip"
            def zipFile = parentPath.resolve(zipFileName)
            project.ant.zip(destfile: zipFile, duplicate: 'fail') {
                imageDir.eachFileRecurse { f ->
                    int mode = f.canExecute() ? 755 : 644
                    def relPath = parentPath.relativize(f.toPath()).toString()
                    zipfileset(dir: parentPath, includes: relPath, filemode: mode)
                }
            }
        }
    }
    distImageZip.mustRunAfter(signDistImage)


    tasks.register('distInstaller', AppInstaller) {
        dependsOn distImage
        distImg = distImage
        types = [installerNameType]
        licenseFile = getRootProject().rootDir.toPath().resolve('jpackage').resolve('LICENSE-Full.txt').toFile()

        //linux
        linuxMenuGroup = ['Applications', 'Science']
        debPackageMaintaner = 'info@bright-giant.com'

        //win
        winUpdateUUID = '5e660105-397c-4ab7-8d7e-69b4ce2c9564'
        winMenuGroup = 'SIRIUS'
    }
    distInstaller.mustRunAfter(signDistImage)


    tasks.register('signDistInstaller') {
        group 'jpDist'
        dependsOn distInstaller
        inputs.dir(distImage.outputDir)
        doLast {
            Path source
            Path target
            if (siriusTargetPlatform.isMac()) {
                def macInstallerIdentity = project.findProperty('de.unijena.bioinf.build.MACOS_IDENTITY_ID')
                //just to check whether a certificate was given
                if (macInstallerIdentity != null && !macInstallerIdentity.isBlank()) {
                    source = distInstaller.getOutputFile().toPath()
                    target = source.getParent().resolve(source.getFileName().toString().replace(".$installerNameType", "-SIGNED.$installerNameType"))
                    getLogger().lifecycle("Signing INSTALLER '$source'")

                    project.exec {
                        commandLine(["/usr/bin/productsign", "--timestamp", "--sign", "${macInstallerIdentity}",
                                     "$source", "$target"
                        ])
                    }

                    getLogger().lifecycle("Replacing source INSTALLER with signed installer")
                    if (target != null && source != null && Files.exists(target))
                        Files.move(target, source, StandardCopyOption.REPLACE_EXISTING)
                } else {
                    getLogger().warn("Could not find apple identity for signign installer. Skipping signing step")
                }
            } else if (siriusTargetPlatform.isWin()) {
                def input = distImage.getImageDir().absolutePath + installerAppendix
                def certFile = project.findProperty('de.unijena.bioinf.build.WIN_INSTALLER_CERTIFICATE_FILE')
                getLogger().lifecycle("Cert File location to use: '$certFile'")
                if (certFile != null && !certFile.isBlank() && file(certFile).exists()) {
                    def searchPaths = [Path.of("${System.getenv("SystemDrive")}\\").resolve("Program Files (x86)").resolve("Windows Kits"), Path.of("${System.getenv("SystemDrive")}\\").resolve("Program Files").resolve("Windows Kits")]
                    getLogger().lifecycle("Searching recursively for signtool.exe in ${searchPaths}")
                    def signtoolExe = searchPaths.stream().filter({ p -> Files.exists(p) }).flatMap({ p -> Files.walk(p) })
                            .filter({ p -> p.getFileName().toString().equalsIgnoreCase('signtool.exe') })
                            .findAny().orElseThrow({ new FileNotFoundException("Could not find signtool.exe!") })
                            .toAbsolutePath().toString()

                    getLogger().lifecycle("Testing  signtool.exe found in '$signtoolExe'")
                    project.exec {
                        commandLine(["$signtoolExe", "/h"])
                        standardOutput = System.out
                    }

                    getLogger().lifecycle("Signing MSI installer using signtool.exe '$input'")
                    def c = ["$signtoolExe", "sign", "/debug", "/f", "${certFile}",
                             "/d", "Installer for the SIRIUS MS/MS analysis Software",
                             "/du", "https://bright-giant.com",
                             "/p", "${findProperty('de.unijena.bioinf.build.WIN_INSTALLER_CERTIFICATE_PW')}", "/v", "/fd", "SHA256",
                             "/tr", "\"${findProperty('de.unijena.bioinf.build.WIN_INSTALLER_CERTIFICATE_TIMESTAMP_URL')}\"", "/td", "SHA256", "$input"]
                    println(c)
                    project.exec {
                        commandLine(c)
                        standardOutput = System.out
                    }
                } else {
                    getLogger().warn("Could not find certificate file for signign installer. Skipping signing step")
                }
            } else if (siriusTargetPlatform.isLinux()) {
                println "Installer signing not yet implemented for Linux"
            }
        }
    }

    tasks.register('macNotarize') {
        group 'jpDist'
        dependsOn signDistInstaller
        inputs.dir(distImage.outputDir)
        doLast {
            if (siriusTargetPlatform.isMac()) {
                def teamId = project.findProperty('de.unijena.bioinf.build.MACOS_TEAM_ID')
                def appleId = project.findProperty('de.unijena.bioinf.build.MACOS_APPLE_ID')
                def appleIdPw = project.findProperty('de.unijena.bioinf.build.MACOS_APPLE_ID_PW')

                if (appleId != null && appleIdPw != null && !appleId.isBlank() && !appleIdPw.isBlank()) {
                    def pkg = distInstaller.getOutputFile().getAbsolutePath()
                    getLogger().lifecycle("Showing available providers")
                    project.exec {
                        commandLine(["xcrun", "altool", "--list-providers",
                                     "-u", "$appleId",
                                     "-p", "$appleIdPw"])
                    }

                    getLogger().lifecycle("Notarizing $pkg...")

                    String uuid = null
                    def so = new ByteArrayOutputStream()
                    def eo = new ByteArrayOutputStream()
                    ExecResult execResult = exec {
                        commandLine(["xcrun", "notarytool", "submit", "--wait", "--apple-id", "${appleId}", "--team-id", "${teamId}",
                                     "--password", "${appleIdPw}", "${pkg}"])
                        standardOutput so
                        errorOutput eo
                    }
                    uuid = (so.toString().split(System.lineSeparator()) as List).stream().filter({ s -> s.contains("id: ") }).findFirst() map({ s -> s.split(":")[1].strip() }).orElseThrow()
                    getLogger().lifecycle("Submitted Notarization Job with RequestUUID: $uuid")

                    int returnCode = execResult.getExitValue()
                    if (returnCode != 0) {
                        throw new GradleException("Error ${returnCode} during notarization.")
                    }

                    getLogger().lifecycle("Requesting Log of $uuid...")
                    execResult = exec {
                        commandLine(["xcrun", "notarytool", "log", "--apple-id", "${appleId}", "--team-id", "${teamId}",
                                     "--password", "${appleIdPw}", "$uuid"])
                    }

                    returnCode = execResult.getExitValue()
                    if (returnCode != 0) {
                        throw new GradleException("Error ${returnCode} during notarization log request.")
                    }


                    getLogger().lifecycle("Stapling  $pkg...")
                    execResult = exec {
                        commandLine(["xcrun", "stapler", "staple", "${pkg}"])
                    }
                    returnCode = execResult.getExitValue()
                    if (returnCode != 0) {
                        throw new GradleException("Error ${returnCode} during stapling.")
                    }
                } else {
                    getLogger().warn("Could not find apple id for notarization. Skipping notarization step")
                }
            }
        }
    }

    tasks.register('createChecksums', Checksum) {
        group 'jpDist'
        mustRunAfter('distImageZip', 'distInstaller', 'macNotarize', 'signDistImage', 'signDistInstaller', 'distZip', 'distTar', 'siriusDistZip', 'siriusDistTar')
        inputFiles.setFrom(fileTree(dir: jpDistDir.get().getAsFile(), includes: ['*.zip', '*.pkg', '*.deb', '*.msi']))
        outputDirectory.set(jpDistDir.get().getAsFile())
        checksumAlgorithm.set(Checksum.Algorithm.SHA256)
        appendFileNameToChecksum.set(true)
    }

    tasks.register('buildJpDists') { group = 'jpDist' }
}


//////////////////////////////////////////////////////////////////////////////////
abstract class ExtractRuntime extends DefaultTask {
    @InputFile
    File inputArchive

    @OutputDirectory
    File outputDir

    ExtractRuntime() {
        group = "runtime"
    }

    @TaskAction
    def execute() {
        //stupid hack to delete write protected files on nix
        getLogger().lifecycle("Unpacking runtime image $inputArchive...")
        outputDir.deleteDir()
        Files.createDirectories(outputDir.toPath())
        project.copy {
            includeEmptyDirs = false
            if (project.siriusTargetPlatform.isWin()) {
                from(project.tarTree(inputArchive)) {
                    eachFile { FileCopyDetails fcd ->
                        fcd.relativePath = new RelativePath(true, fcd.relativePath.segments.drop(1))
                    }
                }
                into outputDir
            } else if (project.siriusTargetPlatform.isLinux() || (project.siriusTargetPlatform.isMac() && project.jre_mac_prefix == null)) {
                from(project.tarTree(inputArchive)) {
                    eachFile { FileCopyDetails fcd ->
                        fcd.relativePath = new RelativePath(true, fcd.relativePath.segments.drop(1))
                    }
                }
                into outputDir
            } else if(project.siriusTargetPlatform.isMac()){
                from(project.tarTree(inputArchive)) {
                    eachFile { FileCopyDetails fcd ->
                        def path = new RelativePath(true, fcd.relativePath.segments.drop(1))
                        println(path)
                        if (path.startsWithAny(project.jre_mac_prefix))
                            fcd.relativePath = new RelativePath(true, path.segments.drop(Path.of(project.jre_mac_prefix).getNameCount()))
                        else
                            fcd.exclude()
                        println(fcd.relativePath)
                        println()
                        println()
                    }
                }
                into outputDir
            }
        }
    }
}

abstract class AppImage extends DefaultTask {

    public File inputDir
    public File jpackagerBin
    public File outputDir
    public String imageName
    public String[] jvmArgs
    public String[] args
    public String version
    public String mainClass
    public String mainJarName
    public File runtimeImageDirectory
    public boolean winConsole
    public Map<String, File> launchers = [:]


    /*--mac-package-name name string
    Name of the application as it appears in the Menu Bar.
    This can be different from the application name.
    This name must be less than 16 characters long and be suitable for displaying in the menu bar and the application Info window. Defaults to the application name.*/
    public String macPackageName = null

    AppImage() {
        group = "jpDist"
        imageName = project.name
        jvmArgs = []
        version = project.siriusTargetPlatform.isLinux() ? project.siriusFrontendVersion : project.siriusFrontendVersion.replace('-SNAPSHOT', '')
        winConsole = false
    }

    @OutputDirectory
    File getImageDir() {
        return outputDir.toPath().resolve(project.siriusTargetPlatform.isMac() ? "${imageName}.app" : imageName).toFile()
    }

    @TaskAction
    def execute() {
        getImageDir().deleteDir()
        String[] p = ['--type', 'app-image']
        p += createParameters()
        project.exec {
            def c = buildCommand(p)
            println c
            commandLine(c)
        }
    }

    def buildCommand(String[] parameters) {
        if (project.OS.isWindows()) {
            getLogger().lifecycle("${jpackagerBin.absolutePath} ${parameters.join(' ')}")
            //because windows command line sucks!
            List<String> c = parameters as List
            c.add(0, "\"${jpackagerBin.absolutePath}\"")
            return c.toArray()
        } else {
            getLogger().lifecycle("${jpackagerBin.absolutePath} ${parameters.join(' ')}")
            return ['bash', '-e', '-c', """
                ${jpackagerBin.absolutePath} ${parameters.join(' ')}
                """]
        }
    }

    String[] createParameters() {
        def paras = [
                '--runtime-image', runtimeImageDirectory.absolutePath,
                '-i', inputDir.absolutePath,
                '--dest', outputDir.toString(),
                '--name', imageName,
                '--app-version', version,
                '--main-class', mainClass,
                '--main-jar', mainJarName
        ]

        if (jvmArgs != null)
            for (String arg : jvmArgs)
                paras += ['--java-options', "\"$arg\"",]

        if (args != null)
            for (String arg : args)
                paras += ['--arguments', "\"$arg\""]

        if (launchers != null && !launchers.isEmpty())
            for (String name : launchers.keySet())
                paras += ["--add-launcher", "\"$name=${launchers.get(name)}\""]


        def iconDir = project.getRootProject().rootDir.toPath().resolve('icons')
        if (project.siriusTargetPlatform.isWin()) {
            paras += ["--icon", "${iconDir.resolve('sirius-icon.ico').toString()}"]
            if (winConsole)
                paras += ['--win-console']
        } else if (project.siriusTargetPlatform.isMac()) {
            paras += ["--icon", "${iconDir.resolve('sirius-icon.icns').toString()}"]
            if (macPackageName != null && !macPackageName.isBlank())
                paras += ['--mac-package-name', "\"$macPackageName\""]
            def signID = project.findProperty("de.unijena.bioinf.build.MACOS_APP_IDENTITY_ID")
            if (signID != null && !signID.isBlank()) {
                paras += ['--mac-sign',
                        '--mac-package-signing-prefix', "\"com.brightgiant\"",
//                          '--mac-signing-keychain', "",
                          '--mac-signing-key-user-name', "\"$signID\"",
                          '--mac-entitlements', "\"${project.getRootProject().getProjectDir().toPath().resolve("dist").resolve("macos.entitlements").toFile().getAbsolutePath()}\"",
                ]
            }
        } else if (project.siriusTargetPlatform.isLinux()) {
            paras += ["--icon", "${iconDir.resolve('sirius-icon.png').toString()}"]
        } else {
            throw new IllegalArgumentException("Could not determine the OS to build on")
        }
        return paras
    }
}

abstract class AppInstaller extends DefaultTask {
    public AppImage distImg
    public String[] types
    public File licenseFile


    public boolean winDirChooser = true
    public boolean winMenu = true
    public String winMenuGroup = null
    public boolean winShortcut
    public boolean winPerUserInstall = false
    public String winUpdateUUID = null


    /*--linux-menu-group <menu-group-name>
          Menu group this application is placed in*/
    public String[] linuxMenuGroup = null
    /* --linux-package-deps
          Required packages or capabilities for the application*/
    public String[] packageDeps = null
    /*--linux-shortcut
          Creates a shortcut for the application*/
    public boolean linuxShortcut = false
    /*--linux-deb-maintainer <email address>
          Maintainer for .deb package*/
    public String debPackageMaintaner = null

    AppInstaller() {
        group = "jpDist"
    }

    @InputDirectory
    File getInputDire() {
        return distImg.getImageDir()
    }

    @OutputFile
    File getOutputFile() {
        return distImg.outputDir.toPath().resolve("${distImg.imageName}-${project.version}-${project.osName}.${project.installerNameType}").toFile()
    }

    @TaskAction
    def execute() {
        String[] p = ['--type', types.join(',')]
        p += createParameters()
        project.exec {
            def c = distImg.buildCommand(p)
            println c
            commandLine(c)
        }

        Files.move(distImg.outputDir.toPath().resolve(distImg.imageName + project.installerAppendix), getOutputFile().toPath())
    }

    @Internal
    String getAppName() {
        return (appName != null && !appName.isBlank()) ? appName : distImg.imageName
    }

    String[] createParameters() {
        String[] paras = []//distImg.createParameters()

        paras += [
                '--verbose',
                '--name', distImg.imageName,
                '--app-image', distImg.getImageDir().absolutePath,
                '--license-file', licenseFile.absolutePath,
                '--dest', distImg.outputDir.absolutePath,
                '--app-version', distImg.version,
//                "--icon", "${project.getRootProject().rootDir.toPath().resolve('icons').resolve('sirius-icon.png').toString()}"
//                '--install-dirr'
        ]


        if (project.siriusTargetPlatform.isWin()) {
            //specify temp directory inside project
            paras += ['--temp', "\"${project.layout.getBuildDirectory().asFile.get().toPath().resolve('tmp').resolve('wix').toAbsolutePath().toString()}\"".toString()]
            //specify resource dir to allow for installer customization.
            paras += ['--resource-dir', "\"${project.getRootProject().rootDir.toPath().resolve('jpackage').resolve('wix-resources').toAbsolutePath().toString()}\"".toString()]
            if (winDirChooser)
                paras += ['--win-dir-chooser'/*, winDirChooser ? '1' : '0'*/]
            if (winMenu)
                paras += ['--win-menu'/*, winMenu ? '1' : '0'*/]
            if (winMenuGroup != null && !winMenuGroup.isBlank())
                paras += ['--win-menu-group', "\"${winMenuGroup}\"".toString()]
            if (winShortcut)
                paras += ['--win-shortcut']
            if (winPerUserInstall)
                paras += ['--win-per-user-install']
            if (winUpdateUUID != null && !winUpdateUUID.isBlank())
                paras += ['--win-upgrade-uuid', "${winUpdateUUID}".toString()]
        } else if (project.siriusTargetPlatform.isMac()) {

        } else if (project.siriusTargetPlatform.isLinux()) {
            if (linuxShortcut)
                paras += ['--linux-shortcut']
            if (debPackageMaintaner != null && !debPackageMaintaner.isBlank())
                paras += ['--linux-deb-maintainer', "\"${debPackageMaintaner}\"".toString()]
            if (linuxMenuGroup != null && linuxMenuGroup.length > 0)
                paras += ['--linux-menu-group', "\"${linuxMenuGroup.join(';')}\"".toString()]
            if (packageDeps != null && packageDeps.length > 0)
                paras += ['--linux-deb-maintainer', "\"${packageDeps.join(',')}\"".toString()]
        } else {
            throw new IllegalArgumentException("Could not determine the OS to build on")
        }
        return paras
    }
}
