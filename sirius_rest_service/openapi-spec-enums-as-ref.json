{
  "openapi": "3.0.1",
  "info": {
    "title": "SIRIUS Nightsky API",
    "description": "REST API that provides the full functionality of SIRIUS and its web services as background service. It is intended as entry-point for scripting languages and software integration SDKs.This API is exposed by SIRIUS 6",
    "version": "3.1"
  },
  "servers": [
    {
      "url": "http://localhost:8888",
      "description": "Generated server url"
    }
  ],
  "tags": [
    {
      "name": "Info",
      "description": "Status und Information"
    },
    {
      "name": "Feature Statistics",
      "description": "[EXPERIMENTAL] This feature based API allows computing and accessing statistics for features (aligned over runs).All endpoints are experimental and not part of the stable API specification. These endpoints can change at any time, even in minor updates."
    },
    {
      "name": "Jobs",
      "description": "Start, monitor and cancel background jobs."
    },
    {
      "name": "Compounds",
      "description": "This compound based API allows to retrieve all AlignedFeatures that belong to the same compound (also known as a group of ion identities). It also provides for each AlignedFeature the corresponding annotation results (which are usually computed on a per-feature basis)"
    },
    {
      "name": "Gui",
      "description": "Basic GUI Control: Open and close SIRIUS Graphical User Interface (GUI) on specified projects."
    },
    {
      "name": "Projects",
      "description": "Manage SIRIUS projects."
    },
    {
      "name": "Runs",
      "description": "[EXPERIMENTAL] This API allows accessing LC/MS runs. All endpoints are experimental and not part of the stable API specification. These endpoints can change at any time, even in minor updates."
    },
    {
      "name": "Compound Statistics",
      "description": "[EXPERIMENTAL] This compound based API allows allows computing and accessing statistics for compounds (also known as a group of ion identities). All endpoints are experimental and not part of the stable API specification. These endpoints can change at any time, even in minor updates."
    },
    {
      "name": "Tags",
      "description": "[EXPERIMENTAL] This API allows managing tags and tag based data groupings. All endpoints are experimental and not part of the stable API specification. These endpoints can change at any time, even in minor updates."
    },
    {
      "name": "Login and Account",
      "description": "Perform signIn, signOut and signUp. Get tokens and account information."
    },
    {
      "name": "Actuator",
      "description": "Monitor and interact",
      "externalDocs": {
        "description": "Spring Boot Actuator Web API Documentation",
        "url": "https://docs.spring.io/spring-boot/docs/current/actuator-api/html/"
      }
    },
    {
      "name": "Searchable Databases",
      "description": "Manage structure and spectral databases that can be used by various computational methods."
    },
    {
      "name": "Features",
      "description": "This feature based API allows access features (aligned over runs) and there Annotations of a specified project-space. This is the entry point to access all raw annotation results an there summaries."
    }
  ],
  "paths": {
    "/api/projects/{projectId}": {
      "get": {
        "tags": [
          "Projects"
        ],
        "summary": "Get project space info by its projectId.",
        "description": "Get project space info by its projectId.",
        "operationId": "getProject",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "unique name/identifier tof the project-space to be accessed.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ProjectInfoOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectInfo"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Projects"
        ],
        "summary": "Open an existing project-space and make it accessible via the given projectId.",
        "description": "Open an existing project-space and make it accessible via the given projectId.",
        "operationId": "openProject",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "unique name/identifier that shall be used to access the opened project-space. Must consist only of [a-zA-Z0-9_-].",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pathToProject",
            "in": "query",
            "description": "local file path to open the project from. If NULL, project will be loaded by it projectId from default project location.  DEPRECATED: This parameter relies on the local filesystem and will likely be removed in later versions of this API to allow for more flexible use cases.",
            "required": false,
            "deprecated": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ProjectInfoOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectInfo"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Projects"
        ],
        "summary": "Create and open a new project-space at given location and make it accessible via the given projectId.",
        "description": "Create and open a new project-space at given location and make it accessible via the given projectId.",
        "operationId": "createProject",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "unique name/identifier that shall be used to access the newly created project-space. Must consist only of [a-zA-Z0-9_-].",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pathToProject",
            "in": "query",
            "description": "local file path where the project will be created. If NULL, project will be stored by its projectId in default project location. DEPRECATED: This parameter relies on the local filesystem and will likely be removed in later versions of this API to allow for more flexible use cases.",
            "required": false,
            "deprecated": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ProjectInfoOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectInfo"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Projects"
        ],
        "summary": "Close project-space and remove it from application",
        "description": "Close project-space and remove it from application. Project will NOT be deleted from disk.\n \u003cp\u003e\n ATTENTION: This will cancel and remove all jobs running on this Project before closing it.\n If there are many jobs, this might take some time.",
        "operationId": "closeProject",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "unique name/identifier of the  project-space to be closed.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "compact",
            "in": "query",
            "description": "if true, compact project storage after closing. DEPRECATED: Compacting acts on the local filesystem and will likely be removed in a later version.",
            "required": false,
            "deprecated": true,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/projects/{projectId}/tags": {
      "get": {
        "tags": [
          "Tags"
        ],
        "summary": "[EXPERIMENTAL] Get all tag definitions in the given project-space",
        "description": "[EXPERIMENTAL] Get all tag definitions in the given project-space.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getTags",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "tagType",
            "in": "query",
            "description": "scope of the tag (optional)",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Tag definitions.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/TagDefinition"
                  }
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Tags"
        ],
        "summary": "[EXPERIMENTAL] Add tags to the project",
        "description": "[EXPERIMENTAL] Add tags to the project. Tag names must not exist in the project.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "createTags",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to add to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "the tag definitions to be created",
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/TagDefinitionImport"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "the definitions of the tags that have been created",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/TagDefinition"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/runs/tags/{runId}": {
      "put": {
        "tags": [
          "Runs"
        ],
        "summary": "[EXPERIMENTAL] Add tags to a run in the project",
        "description": "[EXPERIMENTAL] Add tags to a run in the project. Tags with the same name will be overwritten.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "addTagsToRunExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to add to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "runId",
            "in": "path",
            "description": "run to add tags to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "tags to add.",
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/Tag"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "the tags that have been added",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Tag"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/runs/blanksubtract/compute": {
      "put": {
        "tags": [
          "Runs"
        ],
        "summary": "**EXPERIMENTAL** Compute the fold changes that are required for the fold change filter",
        "description": "**EXPERIMENTAL** Compute the fold changes that are required for the fold change filter.\n\n \u003cp\u003eThis endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.\u003c/p\u003e",
        "operationId": "computeFoldChangeForBlankSubtraction",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to compute the fold change in.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "job opt fields.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/JobOptField"
              },
              "default": [
                "progress"
              ]
            }
          }
        ],
        "requestBody": {
          "description": "request with lists of run IDs that are sample, blank, and control runs",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SampleTypeFoldChangeRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Job"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/copy": {
      "put": {
        "tags": [
          "Projects"
        ],
        "summary": "DEPRECATED: this endpoint is based on local file paths and will likely be removed in future versions of this API.",
        "description": "[DEPRECATED] Move an existing (opened) project-space to another location.\n \u003cp\u003e\n [DEPRECATED] this endpoint is based on local file paths and will likely be removed in future versions of this API.",
        "operationId": "copyProject",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "unique name/identifier of the project-space that shall be copied.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pathToCopiedProject",
            "in": "query",
            "description": "target location where the source project will be copied to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "copyProjectId",
            "in": "query",
            "description": "optional id/mame of the newly created project (copy). If given the project will be opened.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ProjectInfoOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "ProjectInfo of the newly created project if opened (copyProjectId !\u003d null) or the project info of\n the source project otherwise",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectInfo"
                }
              }
            }
          }
        },
        "deprecated": true
      }
    },
    "/api/projects/{projectId}/compounds/tags/{compoundId}": {
      "put": {
        "tags": [
          "Compounds"
        ],
        "summary": "[EXPERIMENTAL] Tags with the same name will be overwritten",
        "description": "[EXPERIMENTAL] Tags with the same name will be overwritten.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "addTagsToCompoundExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to add to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "compoundId",
            "in": "path",
            "description": "compound (group of ion identities) to add tags to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "tags to add.",
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/Tag"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "the tags that have been added",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Tag"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/compounds/statistics/foldchange/compute": {
      "put": {
        "tags": [
          "Compound Statistics"
        ],
        "summary": "[EXPERIMENTAL] Compute the fold change between two groups of runs",
        "description": "[EXPERIMENTAL] Compute the fold change between two groups of runs.\n \u003cp\u003e\n The runs need to be tagged and grouped.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "computeCompoundFoldChangesExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to compute the fold change in.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "leftGroupName",
            "in": "query",
            "description": "name of the left tag group.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "rightGroupName",
            "in": "query",
            "description": "name of the right tag group.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "aggregation",
            "in": "query",
            "description": "aggregation type.",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/AggregationType"
            }
          },
          {
            "name": "quantification",
            "in": "query",
            "description": "quantification type.",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/QuantMeasure"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "job opt fields.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/JobOptField"
              },
              "default": [
                "progress"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Job"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/tags/{alignedFeatureId}": {
      "put": {
        "tags": [
          "Features"
        ],
        "summary": "[EXPERIMENTAL] Add tags to a feature (aligned over runs) in the project",
        "description": "[EXPERIMENTAL] Add tags to a feature (aligned over runs) in the project. Tags with the same name will be overwritten.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "addTagsToAlignedFeatureExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to add to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "run to add tags to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "tags to add.",
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/Tag"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "the tags that have been added",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Tag"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/statistics/foldchange/compute": {
      "put": {
        "tags": [
          "Feature Statistics"
        ],
        "summary": "[EXPERIMENTAL] Compute the fold change between two groups of runs",
        "description": "[EXPERIMENTAL] Compute the fold change between two groups of runs.\n \u003cp\u003e\n The runs need to be tagged and grouped.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "computeAlignedFeatureFoldChangesExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to compute the fold change in.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "leftGroupName",
            "in": "query",
            "description": "name of the left tag group.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "rightGroupName",
            "in": "query",
            "description": "name of the right tag group.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "aggregation",
            "in": "query",
            "description": "aggregation type.",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/AggregationType"
            }
          },
          {
            "name": "quantification",
            "in": "query",
            "description": "quantification type.",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/QuantMeasure"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "job opt fields.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/JobOptField"
              },
              "default": [
                "progress"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Job"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/delete": {
      "put": {
        "tags": [
          "Features"
        ],
        "summary": "Delete feature (aligned over runs) with the given identifier from the specified project-space.",
        "description": "Delete feature (aligned over runs) with the given identifier from the specified project-space.",
        "operationId": "deleteAlignedFeatures",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to delete from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/databases/{databaseId}": {
      "get": {
        "tags": [
          "Searchable Databases"
        ],
        "operationId": "getDatabase",
        "parameters": [
          {
            "name": "databaseId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "includeStats",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchableDatabase"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Searchable Databases"
        ],
        "operationId": "updateDatabase",
        "parameters": [
          {
            "name": "databaseId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchableDatabaseParameters"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchableDatabase"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Searchable Databases"
        ],
        "operationId": "createDatabase",
        "parameters": [
          {
            "name": "databaseId",
            "in": "path",
            "required": true,
            "schema": {
              "pattern": "^[a-zA-Z0-9-_]+$",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchableDatabaseParameters"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchableDatabase"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Searchable Databases"
        ],
        "operationId": "removeDatabase",
        "parameters": [
          {
            "name": "databaseId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "delete",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/account/subscriptions/select-active": {
      "put": {
        "tags": [
          "Login and Account"
        ],
        "summary": "Select a subscription as active subscription to be used for computations.",
        "description": "Select a subscription as active subscription to be used for computations.",
        "operationId": "selectSubscription",
        "parameters": [
          {
            "name": "sid",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Account information with updated active subscription",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountInfo"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/jobs": {
      "get": {
        "tags": [
          "Jobs"
        ],
        "summary": "Get List of all available jobs with information such as current state and progress (if available).",
        "description": "Get List of all available jobs with information such as current state and progress (if available).",
        "operationId": "getJobs",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to run jobs on",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/JobOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Job"
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Jobs"
        ],
        "summary": "Start computation for given compounds and with given parameters.",
        "description": "Start computation for given compounds and with given parameters.",
        "operationId": "startJob",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to run jobs on",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/JobOptField"
              },
              "default": [
                "command",
                "progress"
              ]
            }
          }
        ],
        "requestBody": {
          "description": "configuration of the job that will be submitted of the job to be returned",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/JobSubmission"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Job"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Jobs"
        ],
        "summary": "* Delete ALL jobs.",
        "description": "* Delete ALL jobs. Specify how to behave for running jobs.",
        "operationId": "deleteJobs",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to delete jobs from",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "cancelIfRunning",
            "in": "query",
            "description": "If true, job will be canceled if it is not finished. Otherwise,\n                        deletion will fail for running jobs or request will block until job has finished.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "awaitDeletion",
            "in": "query",
            "description": "If true, request will block until deletion succeeded or failed.\n                        If the job is still running the request will wait until the job has finished.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Accepted"
          }
        }
      }
    },
    "/api/projects/{projectId}/jobs/run-command": {
      "post": {
        "tags": [
          "Jobs"
        ],
        "summary": "[DEPRECATED] Start computation for given command and input",
        "description": "[DEPRECATED] Start computation for given command and input.\n \u003cp\u003e\n [DEPRECATED] this endpoint is based on local file paths and will likely be removed in future versions of this API.",
        "operationId": "startCommand",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to perform the command for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/JobOptField"
              },
              "default": [
                "progress"
              ]
            }
          }
        ],
        "requestBody": {
          "description": "the command and the input to be executed",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CommandSubmission"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Job of the command to be executed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Job"
                }
              }
            }
          }
        },
        "deprecated": true
      }
    },
    "/api/projects/{projectId}/jobs/from-config": {
      "post": {
        "tags": [
          "Jobs"
        ],
        "summary": "Start computation for given compounds and with parameters from a stored job-config.",
        "description": "Start computation for given compounds and with parameters from a stored job-config.",
        "operationId": "startJobFromConfig",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to run jobs on",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "jobConfigName",
            "in": "query",
            "description": "name if the config to be used",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "recompute",
            "in": "query",
            "description": "enable or disable recompute. If null the stored value will be used.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/JobOptField"
              },
              "default": [
                "command",
                "progress"
              ]
            }
          }
        ],
        "requestBody": {
          "description": "List of alignedFeatureIds to be computed",
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Accepted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Job"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/import/preprocessed-local-data-files": {
      "post": {
        "tags": [
          "Projects"
        ],
        "summary": "[DEPRECATED] Import already preprocessed ms/ms data from various formats into the specified project\n Possible formats (ms, mgf, cef, msp)\n ",
        "description": "[DEPRECATED] Import already preprocessed ms/ms data from various formats into the specified project\n Possible formats (ms, mgf, cef, msp)\n \u003cp\u003e\n ATTENTION: This is loading input files from the filesystem where the SIRIUS service is running,\n not on the system where the client SDK is running.\n Is more efficient than MultipartFile upload in cases where client (SDK) and server (SIRIUS service)\n are running on the same host.\n \u003cp\u003e\n API to allow for more flexible use cases. Use \u0027preprocessed-data-files\u0027 instead.\n \u003cp\u003e\n [DEPRECATED] this endpoint is based on local file paths and will likely be removed in future versions of this API.",
        "operationId": "importPreprocessedDataLocally",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to import into.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "ignoreFormulas",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "allowMs1Only",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "requestBody": {
          "description": "files to import into project",
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ImportResult"
                }
              }
            }
          }
        },
        "deprecated": true
      }
    },
    "/api/projects/{projectId}/import/preprocessed-local-data-files-job": {
      "post": {
        "tags": [
          "Projects"
        ],
        "summary": "[DEPRECATED] Import ms/ms data from the given format into the specified project-space as background job",
        "description": "[DEPRECATED] Import ms/ms data from the given format into the specified project-space as background job.\n Possible formats (ms, mgf, cef, msp)\n \u003cp\u003e\n ATTENTION: This is loading input files from the filesystem where the SIRIUS service is running,\n not on the system where the client SDK is running.\n Is more efficient than MultipartFile upload in cases where client (SDK) and server (SIRIUS service)\n are running on the same host.\n \u003cp\u003e\n API to allow for more flexible use cases. Use \u0027preprocessed-data-files-job\u0027 instead.\n \u003cp\u003e\n [DEPRECATED] this endpoint is based on local file paths and will likely be removed in future versions of this API.",
        "operationId": "importPreprocessedDataAsJobLocally",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to import into.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "ignoreFormulas",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "allowMs1Only",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/JobOptField"
              },
              "default": [
                "progress"
              ]
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "the import job.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Job"
                }
              }
            }
          }
        },
        "deprecated": true
      }
    },
    "/api/projects/{projectId}/import/preprocessed-data-files": {
      "post": {
        "tags": [
          "Projects"
        ],
        "summary": "Import already preprocessed ms/ms data from various formats into the specified project\n Possible formats (ms, mgf, cef, msp)",
        "description": "Import already preprocessed ms/ms data from various formats into the specified project\n Possible formats (ms, mgf, cef, msp)",
        "operationId": "importPreprocessedData",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to import into.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "ignoreFormulas",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "allowMs1Only",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "requestBody": {
          "description": "files to import into project",
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "inputFiles": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "format": "binary"
                    }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ImportResult"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/import/preprocessed-data-files-job": {
      "post": {
        "tags": [
          "Projects"
        ],
        "summary": "Import ms/ms data from the given format into the specified project-space as background job.",
        "description": "Import ms/ms data from the given format into the specified project-space as background job.\n Possible formats (ms, mgf, cef, msp)",
        "operationId": "importPreprocessedDataAsJob",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to import into.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "ignoreFormulas",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "allowMs1Only",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/JobOptField"
              },
              "default": [
                "progress"
              ]
            }
          }
        ],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "inputFiles": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "format": "binary"
                    }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "the import job.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Job"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/import/ms-local-data-files": {
      "post": {
        "tags": [
          "Projects"
        ],
        "summary": "[DEPRECATED] Import and Align full MS-Runs from various formats into the specified project\n Possible formats (mzML, mzXML)\n ",
        "description": "[DEPRECATED] Import and Align full MS-Runs from various formats into the specified project\n Possible formats (mzML, mzXML)\n \u003cp\u003e\n ATTENTION: This is loading input files from the filesystem where the SIRIUS service is running,\n not on the system where the client SDK is running.\n Is more efficient than MultipartFile upload in cases where client (SDK) and server (SIRIUS service)\n are running on the same host.\n \u003cp\u003e\n API to allow for more flexible use cases. Use \u0027ms-data-files\u0027 instead.\n \u003cp\u003e\n [DEPRECATED] this endpoint is based on local file paths and will likely be removed in future versions of this API.",
        "operationId": "importMsRunDataLocally",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "Project to import into.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "parameters",
            "in": "query",
            "description": "Parameters for feature alignment and feature finding.",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/LcmsSubmissionParameters"
            }
          }
        ],
        "requestBody": {
          "description": "Local files to import into project.",
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ImportResult"
                }
              }
            }
          }
        },
        "deprecated": true
      }
    },
    "/api/projects/{projectId}/import/ms-data-local-files-job": {
      "post": {
        "tags": [
          "Projects"
        ],
        "summary": "[DEPRECATED] Import and Align full MS-Runs from various formats into the specified project as background job",
        "description": "[DEPRECATED] Import and Align full MS-Runs from various formats into the specified project as background job.\n Possible formats (mzML, mzXML)\n \u003cp\u003e\n ATTENTION: This is loading input files from the filesystem where the SIRIUS service is running,\n not on the system where the client SDK is running.\n Is more efficient than MultipartFile upload in cases where client (SDK) and server (SIRIUS service)\n are running on the same host.\n \u003cp\u003e\n API to allow for more flexible use cases. Use \u0027ms-data-files-job\u0027 instead.\n \u003cp\u003e\n [DEPRECATED] this endpoint is based on local file paths and will likely be removed in future versions of this API.",
        "operationId": "importMsRunDataAsJobLocally",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "Project-space to import into.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "parameters",
            "in": "query",
            "description": "Parameters for feature alignment and feature finding.",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/LcmsSubmissionParameters"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "Set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/JobOptField"
              },
              "default": [
                "progress"
              ]
            }
          }
        ],
        "requestBody": {
          "description": "Local files to import into project.",
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "the import job.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Job"
                }
              }
            }
          }
        },
        "deprecated": true
      }
    },
    "/api/projects/{projectId}/import/ms-data-files": {
      "post": {
        "tags": [
          "Projects"
        ],
        "summary": "Import and Align full MS-Runs from various formats into the specified project\n Possible formats (mzML, mzXML)",
        "description": "Import and Align full MS-Runs from various formats into the specified project\n Possible formats (mzML, mzXML)",
        "operationId": "importMsRunData",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "Project-space to import into.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "Files to import into project.",
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "inputFiles": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "format": "binary"
                    }
                  },
                  "parameters": {
                    "$ref": "#/components/schemas/LcmsSubmissionParameters"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ImportResult"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/import/ms-data-files-job": {
      "post": {
        "tags": [
          "Projects"
        ],
        "summary": "Import and Align full MS-Runs from various formats into the specified project as background job.",
        "description": "Import and Align full MS-Runs from various formats into the specified project as background job.\n Possible formats (mzML, mzXML)",
        "operationId": "importMsRunDataAsJob",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "Project-space to import into.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "Set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/JobOptField"
              },
              "default": [
                "progress"
              ]
            }
          }
        ],
        "requestBody": {
          "description": "Files to import into project.",
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "inputFiles": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "format": "binary"
                    }
                  },
                  "parameters": {
                    "$ref": "#/components/schemas/LcmsSubmissionParameters"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "the import job.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Job"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/gui": {
      "post": {
        "tags": [
          "Gui"
        ],
        "summary": "Open GUI instance on specified project-space and bring the GUI window to foreground.",
        "description": "Open GUI instance on specified project-space and bring the GUI window to foreground.",
        "operationId": "openGui",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "of project-space the GUI instance will connect to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "Created"
          }
        }
      },
      "delete": {
        "tags": [
          "Gui"
        ],
        "summary": "Close GUI instance of given project-space if available.",
        "description": "Close GUI instance of given project-space if available.",
        "operationId": "closeGui",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "if project-space the GUI instance is connected to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "closeProject",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/groups/{groupName}": {
      "get": {
        "tags": [
          "Tags"
        ],
        "summary": "[EXPERIMENTAL] Get tag group by name in the given project-space",
        "description": "[EXPERIMENTAL] Get tag group by name in the given project-space.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getGroupByName",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupName",
            "in": "path",
            "description": "name of the group",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Tag group.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TagGroup"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Tags"
        ],
        "summary": "[EXPERIMENTAL] Group tags in the project",
        "description": "[EXPERIMENTAL] Group tags in the project. The group name must not exist in the project.\n\n \u003cp\u003e\n See \u003ccode\u003e/tagged\u003c/code\u003e for filter syntax.\n \u003c/p\u003e\n\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "addGroup",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to add to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupName",
            "in": "path",
            "description": "name of the new group",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "filter query to create the group",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "type",
            "in": "query",
            "description": "type of the group",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "the tag group that was added",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TagGroup"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Tags"
        ],
        "summary": "[EXPERIMENTAL] Delete tag groups with the given name from the specified project-space",
        "description": "[EXPERIMENTAL] Delete tag groups with the given name from the specified project-space.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "deleteGroup",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to delete from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupName",
            "in": "path",
            "description": "name of group to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/projects/{projectId}/compounds": {
      "get": {
        "tags": [
          "Compounds"
        ],
        "summary": "List of all available compounds (group of ion identities) in the given project-space.",
        "description": "List of all available compounds (group of ion identities) in the given project-space.",
        "operationId": "getCompounds",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "msDataAsCosineQuery",
            "in": "query",
            "description": "Returns all fragment spectra in a preprocessed form as used for fast\n                            Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch\n                            peak assignments and reference spectra.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/CompoundOptField"
              },
              "default": [
                "none"
              ]
            }
          },
          {
            "name": "optFieldsFeatures",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/AlignedFeatureOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Compounds with additional optional fields (if specified).",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Compound"
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Compounds"
        ],
        "summary": "Import Compounds and its contained features.",
        "description": "Import Compounds and its contained features. Compounds and Features must not exist in the project.\n Otherwise, they will exist twice.",
        "operationId": "addCompounds",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to import into.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "profile",
            "in": "query",
            "description": "profile describing the instrument used to measure the data. Used to merge spectra.",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/InstrumentProfile"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/CompoundOptField"
              },
              "default": [
                "none"
              ]
            }
          },
          {
            "name": "optFieldsFeatures",
            "in": "query",
            "description": "set of optional fields of the nested features to be included. Use \u0027none\u0027 to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/AlignedFeatureOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "requestBody": {
          "description": "the compound data to be imported",
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/CompoundImport"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "the Compounds that have been imported with specified optional fields",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Compound"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "Get all available features (aligned over runs) in the given project-space.",
        "description": "Get all available features (aligned over runs) in the given project-space.",
        "operationId": "getAlignedFeatures",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "msDataAsCosineQuery",
            "in": "query",
            "description": "Returns all fragment spectra in a preprocessed form as used for fast\n                            Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch\n                            peak assignments and reference spectra.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/AlignedFeatureOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "AlignedFeatures with additional annotations and MS/MS data (if specified).",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/AlignedFeature"
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Features"
        ],
        "summary": "Import (aligned) features into the project.",
        "description": "Import (aligned) features into the project. Features must not exist in the project.\n Otherwise, they will exist twice.",
        "operationId": "addAlignedFeatures",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to import into.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "profile",
            "in": "query",
            "description": "profile describing the instrument used to measure the data. Used to merge spectra.",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/InstrumentProfile"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/AlignedFeatureOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "requestBody": {
          "description": "the feature data to be imported",
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/FeatureImport"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "the Features that have been imported with specified optional fields",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/AlignedFeature"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/job-configs/{name}": {
      "get": {
        "tags": [
          "Jobs"
        ],
        "summary": "Request job configuration with given name.",
        "description": "Request job configuration with given name.",
        "operationId": "getJobConfig",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the job-config to return",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "moveParametersToConfigMap",
            "in": "query",
            "description": "if true, object-based parameters will be converted to and added to the generic configMap parameters",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "{@link JobSubmission JobSubmission} for given name.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StoredJobSubmission"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Jobs"
        ],
        "summary": "Add new job configuration with given name.",
        "description": "Add new job configuration with given name.",
        "operationId": "saveJobConfig",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the job-config to add",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "overrideExisting",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "moveParametersToConfigMap",
            "in": "query",
            "description": "if true, object-based parameters will be converted to and added to the generic configMap parameters in the return object",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "description": "to add",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/JobSubmission"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "StoredJobSubmission that contains the JobSubmission and the probably modified name of the config (to ensure path compatibility).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StoredJobSubmission"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Jobs"
        ],
        "summary": "Delete job configuration with given name.",
        "description": "Delete job configuration with given name.",
        "operationId": "deleteJobConfig",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "name of the job-config to delete",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Accepted"
          }
        }
      }
    },
    "/api/job-configs/get-command": {
      "post": {
        "tags": [
          "Jobs"
        ],
        "summary": "Get a CLI command for the given job configuration.",
        "description": "Get a CLI command for the given job configuration.",
        "operationId": "getCommand",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/JobSubmission"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/databases": {
      "get": {
        "tags": [
          "Searchable Databases"
        ],
        "operationId": "getDatabases",
        "parameters": [
          {
            "name": "includeStats",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "includeWithErrors",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SearchableDatabase"
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Searchable Databases"
        ],
        "summary": "DEPRECATED: this endpoint is based on local file paths and will likely be replaced in future versions of this API.",
        "operationId": "addDatabases",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SearchableDatabase"
                  }
                }
              }
            }
          }
        },
        "deprecated": true
      }
    },
    "/api/databases/{databaseId}/import/from-files": {
      "post": {
        "tags": [
          "Searchable Databases"
        ],
        "summary": "Start import of structure and spectra files into the specified database.",
        "description": "Start import of structure and spectra files into the specified database.",
        "operationId": "importIntoDatabase",
        "parameters": [
          {
            "name": "databaseId",
            "in": "path",
            "description": "database to import into",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "bufferSize",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 1000
            }
          }
        ],
        "requestBody": {
          "description": "files to be imported",
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "inputFiles": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "format": "binary"
                    }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Job of the import command to be executed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchableDatabase"
                }
              }
            }
          }
        }
      }
    },
    "/api/account/logout": {
      "post": {
        "tags": [
          "Login and Account"
        ],
        "summary": "Logout from SIRIUS web services.",
        "description": "Logout from SIRIUS web services.",
        "operationId": "logout",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/account/login": {
      "post": {
        "tags": [
          "Login and Account"
        ],
        "summary": "Login into SIRIUS web services and activate default subscription if available.",
        "description": "Login into SIRIUS web services and activate default subscription if available.",
        "operationId": "login",
        "parameters": [
          {
            "name": "acceptTerms",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "failWhenLoggedIn",
            "in": "query",
            "description": "if true request fails if an active login already exists.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "includeSubs",
            "in": "query",
            "description": "include available and active subscriptions in {@link AccountInfo AccountInfo}.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "description": "used to log in.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AccountCredentials"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Basic information about the account that has been logged in and its subscriptions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountInfo"
                }
              }
            }
          }
        }
      }
    },
    "/actuator/shutdown": {
      "post": {
        "tags": [
          "Actuator"
        ],
        "summary": "Actuator web endpoint \u0027shutdown\u0027",
        "operationId": "shutdown",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/vnd.spring-boot.actuator.v3+json": {
                "schema": {
                  "type": "object"
                }
              },
              "application/json": {
                "schema": {
                  "type": "object"
                }
              },
              "application/vnd.spring-boot.actuator.v2+json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/tags/{tagName}": {
      "get": {
        "tags": [
          "Tags"
        ],
        "summary": "[EXPERIMENTAL] Get tag definition by its name in the given project-space",
        "description": "[EXPERIMENTAL] Get tag definition by its name in the given project-space.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getTag",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "tagName",
            "in": "path",
            "description": "name of the tag",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Tag definition.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TagDefinition"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Tags"
        ],
        "summary": "[EXPERIMENTAL] Delete tag definition with the given name from the specified project-space",
        "description": "[EXPERIMENTAL] Delete tag definition with the given name from the specified project-space.\n \u003cp\u003e\n This will also remove all tags belonging to this definition from every tagged entity.\n \u003c/p\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "deleteTag",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to delete from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "tagName",
            "in": "path",
            "description": "name of the tag definition to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "patch": {
        "tags": [
          "Tags"
        ],
        "summary": "[EXPERIMENTAL] Add a possible value to the tag definition in the project",
        "description": "[EXPERIMENTAL] Add a possible value to the tag definition in the project.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "addPossibleValuesToTagDefinition",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to add to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "tagName",
            "in": "path",
            "description": "the tag definition to add the values to",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "object"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "the definitions of the tags that have been added",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TagDefinition"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects": {
      "get": {
        "tags": [
          "Projects"
        ],
        "summary": "List opened project spaces.",
        "description": "List opened project spaces.",
        "operationId": "getProjects",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ProjectInfo"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/runs/{runId}": {
      "get": {
        "tags": [
          "Runs"
        ],
        "summary": "[EXPERIMENTAL] Get run with the given identifier from the specified project-space",
        "description": "[EXPERIMENTAL] Get run with the given identifier from the specified project-space.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getRunExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "runId",
            "in": "path",
            "description": "identifier of run to access.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RunOptField"
              },
              "default": []
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Run with tags (if specified).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Run"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/runs/tags/{objectId}": {
      "get": {
        "tags": [
          "Runs"
        ],
        "summary": "[EXPERIMENTAL] Get all tags associated with this Run",
        "description": "[EXPERIMENTAL] Get all tags associated with this Run",
        "operationId": "getTagsForRunExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to get from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "objectId",
            "in": "path",
            "description": "RunId to get tags for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "the tags of the requested object",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Tag"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/runs/tagged": {
      "get": {
        "tags": [
          "Runs"
        ],
        "summary": "[EXPERIMENTAL] Get runs by tag",
        "description": "[EXPERIMENTAL] Get runs by tag.\n\n \u003ch2\u003eSupported filter syntax\u003c/h2\u003e\n\n \u003cp\u003eThe filter string must contain one or more clauses. A clause is prefxed\n by a field name.\n \u003c/p\u003e\n\n Currently the only searchable fields are names of tags (\u003ccode\u003etagName\u003c/code\u003e) followed by a clause that is valued for the value type of the tag (See TagDefinition).\n Tag name based field need to be prefixed with the namespace \u003ccode\u003etags.\u003c/code\u003e.\n Possible value types of tags are \u003cstrong\u003ebool\u003c/strong\u003e, \u003cstrong\u003einteger\u003c/strong\u003e, \u003cstrong\u003ereal\u003c/strong\u003e, \u003cstrong\u003etext\u003c/strong\u003e, \u003cstrong\u003edate\u003c/strong\u003e, or \u003cstrong\u003etime\u003c/strong\u003e - tag value\n\n \u003cp\u003eThe format of the \u003cstrong\u003edate\u003c/strong\u003e type is \u003ccode\u003eyyyy-MM-dd\u003c/code\u003e and of the \u003cstrong\u003etime\u003c/strong\u003e type is \u003ccode\u003eHH\\:mm\\:ss\u003c/code\u003e.\u003c/p\u003e\n\n \u003cp\u003eA clause may be:\u003c/p\u003e\n \u003cul\u003e\n     \u003cli\u003ea \u003cstrong\u003eterm\u003c/strong\u003e: field name followed by a colon and the search term, e.g. \u003ccode\u003etags.MyTagA:sample\u003c/code\u003e\u003c/li\u003e\n     \u003cli\u003ea \u003cstrong\u003ephrase\u003c/strong\u003e: field name followed by a colon and the search phrase in doublequotes, e.g. \u003ccode\u003etags.MyTagA:\u0026quot;Some Text\u0026quot;\u003c/code\u003e\u003c/li\u003e\n     \u003cli\u003ea \u003cstrong\u003eregular expression\u003c/strong\u003e: field name followed by a colon and the regex in slashes, e.g. \u003ccode\u003etags.MyTagA:/[mb]oat/\u003c/code\u003e\u003c/li\u003e\n     \u003cli\u003ea \u003cstrong\u003ecomparison\u003c/strong\u003e: field name followed by a comparison operator and a value, e.g. \u003ccode\u003etags.MyTagB\u0026lt;3\u003c/code\u003e\u003c/li\u003e\n     \u003cli\u003ea \u003cstrong\u003erange\u003c/strong\u003e: field name followed by a colon and an open (indiced by \u003ccode\u003e[ \u003c/code\u003e and \u003ccode\u003e] \u003c/code\u003e) or (semi-)closed range (indiced by \u003ccode\u003e{\u003c/code\u003e and \u003ccode\u003e}\u003c/code\u003e), e.g. \u003ccode\u003etags.MyTagB:[* TO 3] \u003c/code\u003e\u003c/li\u003e\n \u003c/ul\u003e\n\n \u003cp\u003eClauses may be \u003cstrong\u003egrouped\u003c/strong\u003e with brackets \u003ccode\u003e( \u003c/code\u003e and \u003ccode\u003e) \u003c/code\u003e and / or \u003cstrong\u003ejoined\u003c/strong\u003e with \u003ccode\u003eAND\u003c/code\u003e or \u003ccode\u003eOR \u003c/code\u003e (or \u003ccode\u003e\u0026amp;\u0026amp; \u003c/code\u003e and \u003ccode\u003e|| \u003c/code\u003e)\u003c/p\u003e\n\n \u003ch3\u003eExample\u003c/h3\u003e\n\n \u003cp\u003eThe syntax allows to build complex filter queries such as:\u003c/p\u003e\n\n \u003cp\u003e\u003ccode\u003etags.city:\u0026quot;new york\u0026quot; AND tags.ATextTag:/[mb]oat/ AND tags.count:[1 TO *] OR tags.realNumberTag\u0026lt;\u003d3.2 OR tags.MyDateTag:2024-01-01 OR tags.MyDateTag:[2023-10-01 TO 2023-12-24] OR tags.MyDateTag\u0026lt;2022-01-01 OR tags.time:12\\:00\\:00 OR tags.time:[12\\:00\\:00 TO 14\\:00\\:00] OR tags.time\u0026lt;10\\:00\\:00 \u003c/code\u003e\u003c/p\u003e\n\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getRunsByTagExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project space to get runs from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "tag filter.",
            "required": false,
            "schema": {
              "type": "string",
              "default": ""
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "Zero-based page index (0..N)",
            "required": false,
            "schema": {
              "minimum": 0,
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "size",
            "in": "query",
            "description": "The size of the page to be returned",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer",
              "default": 20
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RunOptField"
              },
              "default": []
            }
          }
        ],
        "responses": {
          "200": {
            "description": "tagged runs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PagedModelRun"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/runs/page": {
      "get": {
        "tags": [
          "Runs"
        ],
        "summary": "[EXPERIMENTAL] Get all available runs in the given project-space",
        "description": "[EXPERIMENTAL] Get all available runs in the given project-space.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getRunPageExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "Zero-based page index (0..N)",
            "required": false,
            "schema": {
              "minimum": 0,
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "size",
            "in": "query",
            "description": "The size of the page to be returned",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer",
              "default": 20
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RunOptField"
              },
              "default": []
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Runs with tags (if specified).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PagedModelRun"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/runs/grouped": {
      "get": {
        "tags": [
          "Runs"
        ],
        "summary": "[EXPERIMENTAL] Get runs by tag group",
        "description": "[EXPERIMENTAL] Get runs by tag group.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getRunsByGroupExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to delete from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupName",
            "in": "query",
            "description": "tag group name.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "Zero-based page index (0..N)",
            "required": false,
            "schema": {
              "minimum": 0,
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "size",
            "in": "query",
            "description": "The size of the page to be returned",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer",
              "default": 20
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RunOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "tagged runs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PagedModelRun"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/npc-data": {
      "get": {
        "tags": [
          "Projects"
        ],
        "summary": "Get CANOPUS prediction vector definition for NPC classes",
        "operationId": "getCanopusNpcData",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "charge",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/csv": {
                "schema": {
                  "type": "string"
                }
              },
              "application/CSV": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/jobs/{jobId}": {
      "get": {
        "tags": [
          "Jobs"
        ],
        "summary": "Get job information and its current state and progress (if available).",
        "description": "Get job information and its current state and progress (if available).",
        "operationId": "getJob",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to run jobs on",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "jobId",
            "in": "path",
            "description": "of the job to be returned",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/JobOptField"
              },
              "default": [
                "progress"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Job"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Jobs"
        ],
        "summary": "Delete job.",
        "description": "Delete job. Specify how to behave for running jobs.",
        "operationId": "deleteJob",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to delete job from",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "jobId",
            "in": "path",
            "description": "of the job to be deleted",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "cancelIfRunning",
            "in": "query",
            "description": "If true, job will be canceled if it is not finished. Otherwise,\n                        deletion will fail for running jobs or request will block until job has finished.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "awaitDeletion",
            "in": "query",
            "description": "If true, request will block until deletion succeeded or failed.\n                        If the job is still running the request will wait until the job has finished.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Accepted"
          }
        }
      }
    },
    "/api/projects/{projectId}/jobs/page": {
      "get": {
        "tags": [
          "Jobs"
        ],
        "summary": "Get Page of jobs with information such as current state and progress (if available).",
        "description": "Get Page of jobs with information such as current state and progress (if available).",
        "operationId": "getJobsPaged",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to run jobs on",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "Zero-based page index (0..N)",
            "required": false,
            "schema": {
              "minimum": 0,
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "size",
            "in": "query",
            "description": "The size of the page to be returned",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer",
              "default": 20
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/JobOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PagedModelJob"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/has-jobs": {
      "get": {
        "tags": [
          "Jobs"
        ],
        "operationId": "hasJobs",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "includeFinished",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/groups": {
      "get": {
        "tags": [
          "Tags"
        ],
        "summary": "[EXPERIMENTAL] Get all tag based groups in the given project-space",
        "description": "[EXPERIMENTAL] Get all tag based groups in the given project-space.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getGroups",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupType",
            "in": "query",
            "description": "type of the group",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Groups.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/TagGroup"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/fingerid-data": {
      "get": {
        "tags": [
          "Projects"
        ],
        "summary": "Get CSI:FingerID fingerprint (prediction vector) definition",
        "operationId": "getFingerIdData",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "charge",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/csv": {
                "schema": {
                  "type": "string"
                }
              },
              "application/CSV": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/compounds/{compoundId}": {
      "get": {
        "tags": [
          "Compounds"
        ],
        "summary": "Get compound (group of ion identities) with the given identifier from the specified project-space.",
        "description": "Get compound (group of ion identities) with the given identifier from the specified project-space.",
        "operationId": "getCompound",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "compoundId",
            "in": "path",
            "description": "identifier of the compound (group of ion identities) to access.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "msDataAsCosineQuery",
            "in": "query",
            "description": "Returns all fragment spectra in a preprocessed form as used for fast\n                            Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch\n                            peak assignments and reference spectra.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/CompoundOptField"
              },
              "default": [
                "none"
              ]
            }
          },
          {
            "name": "optFieldsFeatures",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/AlignedFeatureOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Compounds with additional optional fields (if specified).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Compound"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Compounds"
        ],
        "summary": "Delete compound (group of ion identities) with the given identifier (and the included features) from the\n specified project-space.",
        "description": "Delete compound (group of ion identities) with the given identifier (and the included features) from the\n specified project-space.",
        "operationId": "deleteCompound",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to delete from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "compoundId",
            "in": "path",
            "description": "identifier of the compound to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/projects/{projectId}/compounds/{compoundId}/traces": {
      "get": {
        "tags": [
          "Compounds"
        ],
        "summary": "[EXPERIMENTAL] Returns the traces of the given compound",
        "description": "[EXPERIMENTAL] Returns the traces of the given compound.\n \u003cp\u003e\n A trace consists of m/z and intensity values over the retention\n time axis. All the returned traces are \u0027projected\u0027, which means they refer not to the original retention time axis,\n but to a recalibrated axis. This means the data points in the trace are not exactly the same as in the raw data.\n However, this also means that all traces can be directly compared against each other, as they all lie in the same\n retention time axis.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.*",
        "operationId": "getCompoundTracesExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "compoundId",
            "in": "path",
            "description": "compound which intensities should be read out",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "featureId",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "default": ""
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Traces of the given compound.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TraceSetExperimental"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/compounds/{compoundId}/quant-table-row": {
      "get": {
        "tags": [
          "Compounds"
        ],
        "summary": "[EXPERIMENTAL] Returns a single quantification table row for the given compound",
        "description": "[EXPERIMENTAL] Returns a single quantification table row for the given compound.\n \u003cp\u003e\n The quantification table contains a quantification of the feature within all\n samples it is contained in.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.*",
        "operationId": "getCompoundQuantTableRowExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "compoundId",
            "in": "path",
            "description": "compound which should be read out",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "type",
            "in": "query",
            "description": "quantification type.",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/QuantMeasure"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuantTableExperimental"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/compounds/tags/{objectId}": {
      "get": {
        "tags": [
          "Compounds"
        ],
        "summary": "[EXPERIMENTAL] Get all tags associated with this Compound",
        "description": "[EXPERIMENTAL] Get all tags associated with this Compound",
        "operationId": "getTagsForCompoundExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to get from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "objectId",
            "in": "path",
            "description": "CompoundId to get tags for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "the tags of the requested Compound",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Tag"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/compounds/tagged": {
      "get": {
        "tags": [
          "Compounds"
        ],
        "summary": "[EXPERIMENTAL] Get compounds (group of ion identities) by tag",
        "description": "[EXPERIMENTAL] Get compounds (group of ion identities) by tag.\n\n \u003ch2\u003eSupported filter syntax\u003c/h2\u003e\n\n \u003cp\u003eThe filter string must contain one or more clauses. A clause is prefxed\n by a field name.\n \u003c/p\u003e\n\n Currently the only searchable fields are names of tags (\u003ccode\u003etagName\u003c/code\u003e) followed by a clause that is valued for the value type of the tag (See TagDefinition).\n Tag name based field need to be prefixed with the namespace \u003ccode\u003etags.\u003c/code\u003e.\n Possible value types of tags are \u003cstrong\u003ebool\u003c/strong\u003e, \u003cstrong\u003einteger\u003c/strong\u003e, \u003cstrong\u003ereal\u003c/strong\u003e, \u003cstrong\u003etext\u003c/strong\u003e, \u003cstrong\u003edate\u003c/strong\u003e, or \u003cstrong\u003etime\u003c/strong\u003e - tag value\n\n \u003cp\u003eThe format of the \u003cstrong\u003edate\u003c/strong\u003e type is \u003ccode\u003eyyyy-MM-dd\u003c/code\u003e and of the \u003cstrong\u003etime\u003c/strong\u003e type is \u003ccode\u003eHH\\:mm\\:ss\u003c/code\u003e.\u003c/p\u003e\n\n \u003cp\u003eA clause may be:\u003c/p\u003e\n \u003cul\u003e\n     \u003cli\u003ea \u003cstrong\u003eterm\u003c/strong\u003e: field name followed by a colon and the search term, e.g. \u003ccode\u003etags.MyTagA:sample\u003c/code\u003e\u003c/li\u003e\n     \u003cli\u003ea \u003cstrong\u003ephrase\u003c/strong\u003e: field name followed by a colon and the search phrase in doublequotes, e.g. \u003ccode\u003etags.MyTagA:\u0026quot;Some Text\u0026quot;\u003c/code\u003e\u003c/li\u003e\n     \u003cli\u003ea \u003cstrong\u003eregular expression\u003c/strong\u003e: field name followed by a colon and the regex in slashes, e.g. \u003ccode\u003etags.MyTagA:/[mb]oat/\u003c/code\u003e\u003c/li\u003e\n     \u003cli\u003ea \u003cstrong\u003ecomparison\u003c/strong\u003e: field name followed by a comparison operator and a value, e.g. \u003ccode\u003etags.MyTagB\u0026lt;3\u003c/code\u003e\u003c/li\u003e\n     \u003cli\u003ea \u003cstrong\u003erange\u003c/strong\u003e: field name followed by a colon and an open (indiced by \u003ccode\u003e[ \u003c/code\u003e and \u003ccode\u003e] \u003c/code\u003e) or (semi-)closed range (indiced by \u003ccode\u003e{\u003c/code\u003e and \u003ccode\u003e}\u003c/code\u003e), e.g. \u003ccode\u003etags.MyTagB:[* TO 3] \u003c/code\u003e\u003c/li\u003e\n \u003c/ul\u003e\n\n \u003cp\u003eClauses may be \u003cstrong\u003egrouped\u003c/strong\u003e with brackets \u003ccode\u003e( \u003c/code\u003e and \u003ccode\u003e) \u003c/code\u003e and / or \u003cstrong\u003ejoined\u003c/strong\u003e with \u003ccode\u003eAND\u003c/code\u003e or \u003ccode\u003eOR \u003c/code\u003e (or \u003ccode\u003e\u0026amp;\u0026amp; \u003c/code\u003e and \u003ccode\u003e|| \u003c/code\u003e)\u003c/p\u003e\n\n \u003ch3\u003eExample\u003c/h3\u003e\n\n \u003cp\u003eThe syntax allows to build complex filter queries such as:\u003c/p\u003e\n\n \u003cp\u003e\u003ccode\u003etags.city:\u0026quot;new york\u0026quot; AND tags.ATextTag:/[mb]oat/ AND tags.count:[1 TO *] OR tags.realNumberTag\u0026lt;\u003d3.2 OR tags.MyDateTag:2024-01-01 OR tags.MyDateTag:[2023-10-01 TO 2023-12-24] OR tags.MyDateTag\u0026lt;2022-01-01 OR tags.time:12\\:00\\:00 OR tags.time:[12\\:00\\:00 TO 14\\:00\\:00] OR tags.time\u0026lt;10\\:00\\:00 \u003c/code\u003e\u003c/p\u003e\n\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getCompoundsByTagExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project space to get compounds (group of ion identities) from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "tag filter.",
            "required": false,
            "schema": {
              "type": "string",
              "default": ""
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "Zero-based page index (0..N)",
            "required": false,
            "schema": {
              "minimum": 0,
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "size",
            "in": "query",
            "description": "The size of the page to be returned",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer",
              "default": 20
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/CompoundOptField"
              },
              "default": []
            }
          }
        ],
        "responses": {
          "200": {
            "description": "tagged compounds (group of ion identities)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PagedModelCompound"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/compounds/statistics/foldchanges/{objectId}": {
      "get": {
        "tags": [
          "Compound Statistics"
        ],
        "summary": "[EXPERIMENTAL] List all fold changes that are associated with an object",
        "description": "[EXPERIMENTAL] List all fold changes that are associated with an object.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getFoldChangesByCompoundExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "objectId",
            "in": "path",
            "description": "id of the object the fold changes are assigned to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "fold changes",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/FoldChange"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/compounds/statistics/foldchanges/stats-table": {
      "get": {
        "tags": [
          "Compound Statistics"
        ],
        "summary": "[EXPERIMENTAL] Get table of all fold changes in the project space",
        "description": "[EXPERIMENTAL] Get table of all fold changes in the project space.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getCompoundFoldChangeTableExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "aggregation",
            "in": "query",
            "description": "aggregation type.",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/AggregationType"
            }
          },
          {
            "name": "quantification",
            "in": "query",
            "description": "quantification type.",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/QuantMeasure"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "table of fold changes.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StatisticsTable"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/compounds/quant-table": {
      "get": {
        "tags": [
          "Compounds"
        ],
        "summary": "[EXPERIMENTAL] Returns the full quantification table of compounds",
        "description": "[EXPERIMENTAL] Returns the full quantification table of compounds.\n \u003cp\u003e\n The quantification table contains a quantification of the features within all\n runs they are contained in.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.*",
        "operationId": "getCompoundQuantTableExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "type",
            "in": "query",
            "description": "quantification type.",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/QuantMeasure"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuantTableExperimental"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/compounds/page": {
      "get": {
        "tags": [
          "Compounds"
        ],
        "summary": "Page of available compounds (group of ion identities) in the given project-space.",
        "description": "Page of available compounds (group of ion identities) in the given project-space.",
        "operationId": "getCompoundsPaged",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "Zero-based page index (0..N)",
            "required": false,
            "schema": {
              "minimum": 0,
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "size",
            "in": "query",
            "description": "The size of the page to be returned",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer",
              "default": 20
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "msDataAsCosineQuery",
            "in": "query",
            "description": "Returns all fragment spectra in a preprocessed form as used for fast\n                            Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch\n                            peak assignments and reference spectra.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/CompoundOptField"
              },
              "default": [
                "none"
              ]
            }
          },
          {
            "name": "optFieldsFeatures",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/AlignedFeatureOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Compounds with additional optional fields (if specified).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PagedModelCompound"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/compounds/grouped": {
      "get": {
        "tags": [
          "Compounds"
        ],
        "summary": "[EXPERIMENTAL] Get compounds (group of ion identities) by tag group",
        "description": "[EXPERIMENTAL] Get compounds (group of ion identities) by tag group.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getCompoundsByGroupExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to delete from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupName",
            "in": "query",
            "description": "tag group name.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "Zero-based page index (0..N)",
            "required": false,
            "schema": {
              "minimum": 0,
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "size",
            "in": "query",
            "description": "The size of the page to be returned",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer",
              "default": 20
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/CompoundOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "tagged compounds (group of ion identities)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PagedModelCompound"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/cf-data": {
      "get": {
        "tags": [
          "Projects"
        ],
        "summary": "Get CANOPUS prediction vector definition for ClassyFire classes",
        "operationId": "getCanopusClassyFireData",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "charge",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/csv": {
                "schema": {
                  "type": "string"
                }
              },
              "application/CSV": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "Get feature (aligned over runs) with the given identifier from the specified project-space.",
        "description": "Get feature (aligned over runs) with the given identifier from the specified project-space.",
        "operationId": "getAlignedFeature",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "identifier of feature (aligned over runs) to access.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "msDataAsCosineQuery",
            "in": "query",
            "description": "Returns all fragment spectra in a preprocessed form as used for fast\n                            Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch\n                            peak assignments and reference spectra.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/AlignedFeatureOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "AlignedFeature with additional annotations and MS/MS data (if specified).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlignedFeature"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Features"
        ],
        "summary": "Delete feature (aligned over runs) with the given identifier from the specified project-space.",
        "description": "Delete feature (aligned over runs) with the given identifier from the specified project-space.",
        "operationId": "deleteAlignedFeature",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to delete from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "identifier of feature (aligned over runs) to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/traces": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "[EXPERIMENTAL] Returns the traces of the given feature (alignedFeatureId)",
        "description": "[EXPERIMENTAL] Returns the traces of the given feature (alignedFeatureId).\n \u003cp\u003e\n Returns the traces of the given feature. A trace consists of m/z and intensity values over the retention\n time axis. All the returned traces are \u0027projected\u0027, which means they refer not to the original retention time axis,\n but to a recalibrated axis. This means the data points in the trace are not exactly the same as in the raw data.\n However, this also means that all traces can be directly compared against each other, as they all lie in the same\n retention time axis.\n By default, this method only returns traces of samples the aligned feature appears in. When includeAll is set,\n it also includes samples in which the same trace appears in.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getTracesExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature which intensities should be read out",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "includeAll",
            "in": "query",
            "description": "when true, return all samples that belong to the same merged trace. when false, only return samples which contain the aligned feature.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Traces of the given feature.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TraceSetExperimental"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/spectral-library-matches": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "List of spectral library matches for the given \u0027alignedFeatureId\u0027.",
        "description": "List of spectral library matches for the given \u0027alignedFeatureId\u0027.",
        "operationId": "getSpectralLibraryMatches",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the structure candidates belong to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "minSharedPeaks",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 1
            }
          },
          {
            "name": "minSimilarity",
            "in": "query",
            "required": false,
            "schema": {
              "type": "number",
              "format": "double",
              "default": 0.2
            }
          },
          {
            "name": "inchiKey",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "default": ""
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/SpectralLibraryMatchOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Spectral library matches of this feature (aligned over runs).",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SpectralLibraryMatch"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/spectral-library-matches/{matchId}": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "Spectral library match for the given \u0027alignedFeatureId\u0027.",
        "description": "Spectral library match for the given \u0027alignedFeatureId\u0027.",
        "operationId": "getSpectralLibraryMatch",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the structure candidates belong to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "matchId",
            "in": "path",
            "description": "id of the library match to be returned.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/SpectralLibraryMatchOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Spectral library match with requested mathcId.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpectralLibraryMatch"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/spectral-library-matches/{matchId}/annotated": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "[EXPERIMENTAL] Spectral library match for the given \u0027alignedFeatureId\u0027 with additional molecular formula and substructure annotations",
        "description": "[EXPERIMENTAL] Spectral library match for the given \u0027alignedFeatureId\u0027 with additional molecular formula and substructure annotations.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getStructureAnnotatedSpectralLibraryMatchExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the structure candidates belong to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "matchId",
            "in": "path",
            "description": "id of the library match to be returned.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Spectral library match with requested mathcId.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnnotatedSpectrum"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/spectral-library-matches/summary": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "Summarize matched reference spectra for the given \u0027alignedFeatureId\u0027.",
        "description": "Summarize matched reference spectra for the given \u0027alignedFeatureId\u0027.\n If a \u0027inchiKey\u0027 (2D) is provided, summarizes only contains matches for the database compound with the given InChI key.",
        "operationId": "getSpectralLibraryMatchesSummary",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the structure candidates belong to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "minSharedPeaks",
            "in": "query",
            "description": "min threshold of shared peaks.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 1
            }
          },
          {
            "name": "minSimilarity",
            "in": "query",
            "description": "min spectral similarity threshold.",
            "required": false,
            "schema": {
              "type": "number",
              "format": "double",
              "default": 0.2
            }
          },
          {
            "name": "inchiKey",
            "in": "query",
            "description": "2D inchi key of the compound in the structure database.",
            "required": false,
            "schema": {
              "type": "string",
              "default": ""
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Summary object with best match, number of spectral library matches, matched reference spectra and matched database compounds of this feature (aligned over runs).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SpectralLibraryMatchSummary"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/spectral-library-matches/page": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "Page of spectral library matches for the given \u0027alignedFeatureId\u0027.",
        "description": "Page of spectral library matches for the given \u0027alignedFeatureId\u0027.\n If a \u0027inchiKey\u0027 (2D) is provided, returns only matches for the database compound with the given InChI key.",
        "operationId": "getSpectralLibraryMatchesPaged",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the structure candidates belong to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "Zero-based page index (0..N)",
            "required": false,
            "schema": {
              "minimum": 0,
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "size",
            "in": "query",
            "description": "The size of the page to be returned",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer",
              "default": 20
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "minSharedPeaks",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 1
            }
          },
          {
            "name": "minSimilarity",
            "in": "query",
            "required": false,
            "schema": {
              "type": "number",
              "format": "double",
              "default": 0.2
            }
          },
          {
            "name": "inchiKey",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "default": ""
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/SpectralLibraryMatchOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Spectral library matches of this feature (aligned over runs).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PagedModelSpectralLibraryMatch"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/quant-table-row": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "[EXPERIMENTAL] Returns a single quantification table row for the given feature (alignedFeatureId)",
        "description": "[EXPERIMENTAL] Returns a single quantification table row for the given feature (alignedFeatureId).\n \u003cp\u003e\n The quantification table contains a quantity of the feature within all samples it is contained in.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getQuantTableRowExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature which quantity should be read out",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "type",
            "in": "query",
            "description": "quantification type. Currently, only APEX_HEIGHT is supported, which is the intensity of the feature at its apex.",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/QuantMeasure"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Quant table row for this feature",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuantTableExperimental"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/quality-report": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "[EXPERIMENTAL] Returns data quality information for given feature (alignedFeatureId)\n ",
        "description": "[EXPERIMENTAL] Returns data quality information for given feature (alignedFeatureId)\n \u003cp\u003e\n Get data quality information for feature (aligned over runs) with the given identifier from the specified project-space.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getAlignedFeatureQualityExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "identifier of feature (aligned over runs) to access.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "AlignedFeatureQuality quality information of the respective feature.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AlignedFeatureQualityExperimental"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/ms-data": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "Mass Spec data (input data) for the given \u0027alignedFeatureId\u0027 .",
        "description": "Mass Spec data (input data) for the given \u0027alignedFeatureId\u0027 .",
        "operationId": "getMsData",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the Mass Spec data belongs to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "asCosineQuery",
            "in": "query",
            "description": "Returns all fragment spectra in a preprocessed form as used for fast\n                         Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch\n                         peak assignments and reference spectra.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Mass Spec data of this feature (aligned over runs).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MsData"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "List of FormulaResultContainers available for this feature with minimal information.",
        "description": "List of FormulaResultContainers available for this feature with minimal information.\n Can be enriched with an optional results overview.",
        "operationId": "getFormulaCandidates",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the formula result belongs to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "msDataAsCosineQuery",
            "in": "query",
            "description": "Returns all fragment spectra in a preprocessed form as used for fast\n                            Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch\n                            peak assignments and reference spectra.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/FormulaCandidateOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "All FormulaCandidate of this feature with.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/FormulaCandidate"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "FormulaResultContainers for the given \u0027formulaId\u0027 with minimal information.",
        "description": "FormulaResultContainers for the given \u0027formulaId\u0027 with minimal information.\n Can be enriched with an optional results overview and formula candidate information.",
        "operationId": "getFormulaCandidate",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the formula result belongs to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "formulaId",
            "in": "path",
            "description": "identifier of the requested formula result",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "msDataAsCosineQuery",
            "in": "query",
            "description": "Returns all fragment spectra in a preprocessed form as used for fast\n                            Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch\n                            peak assignments and reference spectra.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/FormulaCandidateOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "FormulaCandidate of this feature (aligned over runs) with.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FormulaCandidate"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/structures/{inchiKey}/annotated-spectrum": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "[EXPERIMENTAL] Returns a fragmentation spectrum annotated with fragments and losses for the given formulaId and inChIKey\n ",
        "description": "[EXPERIMENTAL] Returns a fragmentation spectrum annotated with fragments and losses for the given formulaId and inChIKey\n \u003cp\u003e\n Returns a fragmentation spectrum (e.g. Merged MS/MS) which is annotated with fragments and losses for the selected formula result\n These annotations are only available if a fragmentation tree is available.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getStructureAnnotatedSpectrumExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the formula result belongs to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "formulaId",
            "in": "path",
            "description": "identifier of the requested formula result",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "inchiKey",
            "in": "path",
            "description": "2d InChIKey of the structure candidate to be used to annotate the spectrum annotation",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "spectrumIndex",
            "in": "query",
            "description": "index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex \u003c 0 (default)",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": -1
            }
          },
          {
            "name": "asCosineQuery",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Fragmentation spectrum annotated with fragments and sub-structures.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnnotatedSpectrum"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/structures/{inchiKey}/annotated-msmsdata": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "[EXPERIMENTAL] Returns MS/MS Data annotated with fragments and losses for given formulaId and inChIKey",
        "description": "[EXPERIMENTAL] Returns MS/MS Data annotated with fragments and losses for given formulaId and inChIKey.\n \u003cp\u003e\n Returns MS/MS Data (Merged MS/MS and list of measured MS/MS ) which are annotated with fragments and losses\n for the given formula result identifier and structure candidate inChIKey.\n These annotations are only available if a fragmentation tree and the structure candidate are available.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getStructureAnnotatedMsDataExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the formula result belongs to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "formulaId",
            "in": "path",
            "description": "identifier of the requested formula result",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "inchiKey",
            "in": "path",
            "description": "2d InChIKey of the structure candidate to be used to annotate the spectrum annotation",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "asCosineQuery",
            "in": "query",
            "description": "Returns all fragment spectra in a preprocessed form as used for fast\n                         Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch\n                         peak assignments and reference spectra.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Fragmentation spectrum annotated with fragments and sub-structures.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnnotatedMsMsData"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/sirius-fragtree": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "[INTERNAL] Returns fragmentation tree (SIRIUS) for the given formula result identifier in SIRIUS\u0027 internal format",
        "description": "[INTERNAL] Returns fragmentation tree (SIRIUS) for the given formula result identifier in SIRIUS\u0027 internal format.\n \u003cp\u003e\n [INTERNAL]: This is an internal api endpoint and not part of the official public API. It might be changed or removed at any time.",
        "operationId": "getSiriusFragTreeInternal",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the formula result belongs to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "formulaId",
            "in": "path",
            "description": "identifier of the requested formula result",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Fragmentation Tree in internal format.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/lipid-annotation": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "Returns Lipid annotation (ElGordo) for the given formulaId",
        "description": "Returns Lipid annotation (ElGordo) for the given formulaId.\n \u003cp\u003e\n ElGordo lipid annotation runs as part of the SIRIUS formula identification step.",
        "operationId": "getLipidAnnotation",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the formula result belongs to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "formulaId",
            "in": "path",
            "description": "identifier of the requested formula result",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "LipidAnnotation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LipidAnnotation"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/isotope-pattern": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "Returns Isotope pattern information for given formulaId\n ",
        "description": "Returns Isotope pattern information for given formulaId\n \u003cp\u003e\n Returns Isotope pattern information (simulated isotope pattern, measured isotope pattern, isotope pattern highlighting)\n for the given formula result identifier. This simulated isotope pattern is used to rank formula candidates (treeScore).",
        "operationId": "getIsotopePatternAnnotation",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the formula result belongs to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "formulaId",
            "in": "path",
            "description": "identifier of the requested formula result",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Isotope pattern information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IsotopePatternAnnotation"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/fragtree": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "Returns fragmentation tree (SIRIUS) for the given formula result identifier\n ",
        "description": "Returns fragmentation tree (SIRIUS) for the given formula result identifier\n \u003cp\u003e\n This tree is used to rank formula candidates (treeScore).",
        "operationId": "getFragTree",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the formula result belongs to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "formulaId",
            "in": "path",
            "description": "identifier of the requested formula result",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Fragmentation Tree",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FragmentationTree"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/fingerprint": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier (formulaId)\n ",
        "description": "Returns predicted fingerprint (CSI:FingerID) for the given formula result identifier (formulaId)\n \u003cp\u003e\n This fingerprint is used to perform structure database search and predict compound classes.",
        "operationId": "getFingerprintPrediction",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the formula result belongs to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "formulaId",
            "in": "path",
            "description": "identifier of the requested formula result",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "probabilistic fingerprint predicted by CSI:FingerID",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "number",
                    "format": "double"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/denovo-structures": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given \u0027formulaId\u0027 with minimal information.\n StructureCandidates can be enriched with molecular fingerprint.",
        "description": "List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given \u0027formulaId\u0027 with minimal information.\n StructureCandidates can be enriched with molecular fingerprint.",
        "operationId": "getDeNovoStructureCandidatesByFormula",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the formula result belongs to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "formulaId",
            "in": "path",
            "description": "identifier of the requested formula result",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/StructureCandidateOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "StructureCandidate of this formula candidate with specified optional fields.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/StructureCandidateScored"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/denovo-structures/page": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given \u0027formulaId\u0027 with minimal information.\n StructureCandidates can be enriched with molecular fingerprint.",
        "description": "Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given \u0027formulaId\u0027 with minimal information.\n StructureCandidates can be enriched with molecular fingerprint.",
        "operationId": "getDeNovoStructureCandidatesByFormulaPaged",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the formula result belongs to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "formulaId",
            "in": "path",
            "description": "identifier of the requested formula result",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "Zero-based page index (0..N)",
            "required": false,
            "schema": {
              "minimum": 0,
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "size",
            "in": "query",
            "description": "The size of the page to be returned",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer",
              "default": 20
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/StructureCandidateOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "StructureCandidate of this formula candidate with specified optional fields.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PagedModelStructureCandidateScored"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/db-structures": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "List of CSI:FingerID structure database search candidates for the given \u0027formulaId\u0027 with minimal information.",
        "description": "List of CSI:FingerID structure database search candidates for the given \u0027formulaId\u0027 with minimal information.\n StructureCandidates can be enriched with molecular fingerprint, structure database links.",
        "operationId": "getStructureCandidatesByFormula",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the formula result belongs to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "formulaId",
            "in": "path",
            "description": "identifier of the requested formula result",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/StructureCandidateOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "StructureCandidate of this formula candidate with specified optional fields.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/StructureCandidateScored"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/db-structures/page": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "Page of CSI:FingerID structure database search candidates for the given \u0027formulaId\u0027 with minimal information.",
        "description": "Page of CSI:FingerID structure database search candidates for the given \u0027formulaId\u0027 with minimal information.\n StructureCandidates can be enriched with molecular fingerprint, structure database links.",
        "operationId": "getStructureCandidatesByFormulaPaged",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the formula result belongs to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "formulaId",
            "in": "path",
            "description": "identifier of the requested formula result",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "Zero-based page index (0..N)",
            "required": false,
            "schema": {
              "minimum": 0,
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "size",
            "in": "query",
            "description": "The size of the page to be returned",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer",
              "default": 20
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/StructureCandidateOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "StructureCandidate of this formula candidate with specified optional fields.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PagedModelStructureCandidateScored"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/canopus-prediction": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,",
        "description": "All predicted compound classes (CANOPUS) from ClassyFire and NPC and their probabilities,",
        "operationId": "getCanopusPrediction",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the formula result belongs to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "formulaId",
            "in": "path",
            "description": "identifier of the requested formula result",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Predicted compound classes",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CanopusPrediction"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/best-compound-classes": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "Return Best matching compound classes for given formulaId",
        "description": "Return Best matching compound classes for given formulaId.\n \u003cp\u003e\n Set of the highest scoring compound classes (CANOPUS) on each hierarchy level of  the ClassyFire and NPC ontology,",
        "operationId": "getBestMatchingCompoundClasses",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the formula result belongs to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "formulaId",
            "in": "path",
            "description": "identifier of the requested formula result",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Best matching Predicted compound classes",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CompoundClasses"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/annotated-spectrum": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "Returns a fragmentation spectrum (e",
        "description": "Returns a fragmentation spectrum (e.g. Merged MS/MS) which is annotated with fragments and losses for the given formula result identifier\n \u003cp\u003e\n These annotations are only available if a fragmentation tree is available.",
        "operationId": "getFormulaAnnotatedSpectrum",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the formula result belongs to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "formulaId",
            "in": "path",
            "description": "identifier of the requested formula result",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "spectrumIndex",
            "in": "query",
            "description": "index of the spectrum to be annotated. Merged MS/MS will be used if spectrumIndex \u003c 0 (default)",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": -1
            }
          },
          {
            "name": "asCosineQuery",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Fragmentation spectrum annotated with fragment formulas and losses.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnnotatedSpectrum"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/{formulaId}/annotated-msmsdata": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "Returns MS/MS Spectrum annotated with fragments and losses for provided formulaId",
        "description": "Returns MS/MS Spectrum annotated with fragments and losses for provided formulaId.\n \u003cp\u003e\n Returns MS/MS Spectrum (Merged MS/MS and measured MS/MS) which is annotated with fragments and losses\n for the given formula result identifier\n These annotations are only available if a fragmentation tree and the structure candidate are available.",
        "operationId": "getFormulaAnnotatedMsMsData",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the formula result belongs to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "formulaId",
            "in": "path",
            "description": "identifier of the requested formula result",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "asCosineQuery",
            "in": "query",
            "description": "Returns all fragment spectra in a preprocessed form as used for fast\n                         Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch\n                         peak assignments and reference spectra.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Fragmentation spectra annotated with fragment formulas and losses.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnnotatedMsMsData"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/formulas/page": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "Page of FormulaResultContainers available for this feature with minimal information.",
        "description": "Page of FormulaResultContainers available for this feature with minimal information.\n Can be enriched with an optional results overview.",
        "operationId": "getFormulaCandidatesPaged",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the formula result belongs to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "Zero-based page index (0..N)",
            "required": false,
            "schema": {
              "minimum": 0,
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "size",
            "in": "query",
            "description": "The size of the page to be returned",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer",
              "default": 20
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "msDataAsCosineQuery",
            "in": "query",
            "description": "Returns all fragment spectra in a preprocessed form as used for fast\n                            Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch\n                            peak assignments and reference spectra.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/FormulaCandidateOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "All FormulaCandidate of this feature with.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PagedModelFormulaCandidate"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/denovo-structures": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given \u0027alignedFeatureId\u0027 with minimal information.\n StructureCandidates can be enriched with molecular fingerprint.",
        "description": "List of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given \u0027alignedFeatureId\u0027 with minimal information.\n StructureCandidates can be enriched with molecular fingerprint.",
        "operationId": "getDeNovoStructureCandidates",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the structure candidates belong to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/StructureCandidateOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "StructureCandidate of this feature (aligned over runs) candidate with specified optional fields.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/StructureCandidateFormula"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/denovo-structures/page": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given \u0027alignedFeatureId\u0027 with minimal information.\n StructureCandidates can be enriched with molecular fingerprint.",
        "description": "Page of de novo structure candidates (e.g. generated by MsNovelist) ranked by CSI:FingerID score for the given \u0027alignedFeatureId\u0027 with minimal information.\n StructureCandidates can be enriched with molecular fingerprint.",
        "operationId": "getDeNovoStructureCandidatesPaged",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the structure candidates belong to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "Zero-based page index (0..N)",
            "required": false,
            "schema": {
              "minimum": 0,
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "size",
            "in": "query",
            "description": "The size of the page to be returned",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer",
              "default": 20
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/StructureCandidateOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "StructureCandidate of this feature (aligned over runs) candidate with specified optional fields.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PagedModelStructureCandidateFormula"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/db-structures": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "List of structure database search candidates ranked by CSI:FingerID score for the given \u0027alignedFeatureId\u0027 with minimal information.",
        "description": "List of structure database search candidates ranked by CSI:FingerID score for the given \u0027alignedFeatureId\u0027 with minimal information.\n StructureCandidates can be enriched with molecular fingerprint, structure database links.",
        "operationId": "getStructureCandidates",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the structure candidates belong to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/StructureCandidateOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "StructureCandidate of this feature (aligned over runs) candidate with specified optional fields.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/StructureCandidateFormula"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/db-structures/page": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "Page of structure database search candidates ranked by CSI:FingerID score for the given \u0027alignedFeatureId\u0027 with minimal information.",
        "description": "Page of structure database search candidates ranked by CSI:FingerID score for the given \u0027alignedFeatureId\u0027 with minimal information.\n StructureCandidates can be enriched with molecular fingerprint, structure database links.",
        "operationId": "getStructureCandidatesPaged",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) the structure candidates belong to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "Zero-based page index (0..N)",
            "required": false,
            "schema": {
              "minimum": 0,
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "size",
            "in": "query",
            "description": "The size of the page to be returned",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer",
              "default": 20
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/StructureCandidateOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "StructureCandidate of this feature (aligned over runs) candidate with specified optional fields.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PagedModelStructureCandidateFormula"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/{alignedFeatureId}/adducts": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "[EXPERIMENTAL] Returns the adduct network for a given alignedFeatureId together with all merged traces contained in the network",
        "description": "[EXPERIMENTAL] Returns the adduct network for a given alignedFeatureId together with all merged traces contained in the network.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getAdductNetworkWithMergedTracesExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "one feature that is considered the main feature of the adduct network",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TraceSetExperimental"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/tags/{objectId}": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "[EXPERIMENTAL] Get all tags associated with this Object",
        "description": "[EXPERIMENTAL] Get all tags associated with this Object",
        "operationId": "getTagsForAlignedFeaturesExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to get from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "objectId",
            "in": "path",
            "description": "object to get tags for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "the tags of the requested object",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Tag"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/tagged": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "[EXPERIMENTAL] Get features (aligned over runs) by tag",
        "description": "[EXPERIMENTAL] Get features (aligned over runs) by tag.\n\n \u003ch2\u003eSupported filter syntax\u003c/h2\u003e\n\n \u003cp\u003eThe filter string must contain one or more clauses. A clause is prefxed\n by a field name.\n \u003c/p\u003e\n \u003cp\u003e\n Currently the only searchable fields are names of tags (\u003ccode\u003etagName\u003c/code\u003e) followed by a clause that is valued for the value type of the tag (See TagDefinition).\n Tag name based field need to be prefixed with the namespace \u003ccode\u003etags.\u003c/code\u003e.\n Possible value types of tags are \u003cstrong\u003ebool\u003c/strong\u003e, \u003cstrong\u003einteger\u003c/strong\u003e, \u003cstrong\u003ereal\u003c/strong\u003e, \u003cstrong\u003etext\u003c/strong\u003e, \u003cstrong\u003edate\u003c/strong\u003e, or \u003cstrong\u003etime\u003c/strong\u003e - tag value\n\n \u003cp\u003eThe format of the \u003cstrong\u003edate\u003c/strong\u003e type is \u003ccode\u003eyyyy-MM-dd\u003c/code\u003e and of the \u003cstrong\u003etime\u003c/strong\u003e type is \u003ccode\u003eHH\\:mm\\:ss\u003c/code\u003e.\u003c/p\u003e\n\n \u003cp\u003eA clause may be:\u003c/p\u003e\n \u003cul\u003e\n     \u003cli\u003ea \u003cstrong\u003eterm\u003c/strong\u003e: field name followed by a colon and the search term, e.g. \u003ccode\u003etags.MyTagA:sample\u003c/code\u003e\u003c/li\u003e\n     \u003cli\u003ea \u003cstrong\u003ephrase\u003c/strong\u003e: field name followed by a colon and the search phrase in doublequotes, e.g. \u003ccode\u003etags.MyTagA:\u0026quot;Some Text\u0026quot;\u003c/code\u003e\u003c/li\u003e\n     \u003cli\u003ea \u003cstrong\u003eregular expression\u003c/strong\u003e: field name followed by a colon and the regex in slashes, e.g. \u003ccode\u003etags.MyTagA:/[mb]oat/\u003c/code\u003e\u003c/li\u003e\n     \u003cli\u003ea \u003cstrong\u003ecomparison\u003c/strong\u003e: field name followed by a comparison operator and a value, e.g. \u003ccode\u003etags.MyTagB\u0026lt;3\u003c/code\u003e\u003c/li\u003e\n     \u003cli\u003ea \u003cstrong\u003erange\u003c/strong\u003e: field name followed by a colon and an open (indiced by \u003ccode\u003e[ \u003c/code\u003e and \u003ccode\u003e] \u003c/code\u003e) or (semi-)closed range (indiced by \u003ccode\u003e{\u003c/code\u003e and \u003ccode\u003e}\u003c/code\u003e), e.g. \u003ccode\u003etags.MyTagB:[* TO 3] \u003c/code\u003e\u003c/li\u003e\n \u003c/ul\u003e\n\n \u003cp\u003eClauses may be \u003cstrong\u003egrouped\u003c/strong\u003e with brackets \u003ccode\u003e( \u003c/code\u003e and \u003ccode\u003e) \u003c/code\u003e and / or \u003cstrong\u003ejoined\u003c/strong\u003e with \u003ccode\u003eAND\u003c/code\u003e or \u003ccode\u003eOR \u003c/code\u003e (or \u003ccode\u003e\u0026amp;\u0026amp; \u003c/code\u003e and \u003ccode\u003e|| \u003c/code\u003e)\u003c/p\u003e\n\n \u003ch3\u003eExample\u003c/h3\u003e\n\n \u003cp\u003eThe syntax allows to build complex filter queries such as:\u003c/p\u003e\n\n \u003cp\u003e\u003ccode\u003etags.city:\u0026quot;new york\u0026quot; AND tags.ATextTag:/[mb]oat/ AND tags.count:[1 TO *] OR tags.realNumberTag\u0026lt;\u003d3.2 OR tags.MyDateTag:2024-01-01 OR tags.MyDateTag:[2023-10-01 TO 2023-12-24] OR tags.MyDateTag\u0026lt;2022-01-01 OR tags.time:12\\:00\\:00 OR tags.time:[12\\:00\\:00 TO 14\\:00\\:00] OR tags.time\u0026lt;10\\:00\\:00 \u003c/code\u003e\u003c/p\u003e\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getAlignedFeaturesByTagExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project space to get features (aligned over runs) from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "tag filter.",
            "required": false,
            "schema": {
              "type": "string",
              "default": ""
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "Zero-based page index (0..N)",
            "required": false,
            "schema": {
              "minimum": 0,
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "size",
            "in": "query",
            "description": "The size of the page to be returned",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer",
              "default": 20
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/AlignedFeatureOptField"
              },
              "default": []
            }
          }
        ],
        "responses": {
          "200": {
            "description": "tagged features (aligned over runs)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PagedModelAlignedFeature"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/statistics/foldchanges/{objectId}": {
      "get": {
        "tags": [
          "Feature Statistics"
        ],
        "summary": "[EXPERIMENTAL] List all fold changes that are associated with an object",
        "description": "[EXPERIMENTAL] List all fold changes that are associated with an object.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getFoldChangesByAlignedFeatureExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "objectId",
            "in": "path",
            "description": "id of the object the fold changes are assigned to.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "fold changes",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/FoldChange"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/statistics/foldchanges/stats-table": {
      "get": {
        "tags": [
          "Feature Statistics"
        ],
        "summary": "[EXPERIMENTAL] Get table of all fold changes in the project space",
        "description": "[EXPERIMENTAL] Get table of all fold changes in the project space.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getAlignedFeatureFoldChangeTableExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "aggregation",
            "in": "query",
            "description": "aggregation type.",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/AggregationType"
            }
          },
          {
            "name": "quantification",
            "in": "query",
            "description": "quantification type.",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/QuantMeasure"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "table of fold changes.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StatisticsTable"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/quant-table": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "[EXPERIMENTAL]  Returns the full quantification table for the given feature (alignedFeatureId)",
        "description": "[EXPERIMENTAL]  Returns the full quantification table for the given feature (alignedFeatureId).\n \u003cp\u003e\n Returns the full quantification table. The quantification table contains a quantities of the features within all\n runs they are contained in.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getFeatureQuantTableExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "type",
            "in": "query",
            "description": "quantification type.",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/QuantMeasure"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Quant table if akk feature in this project",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuantTableExperimental"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/page": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "Get all available features (aligned over runs) in the given project-space.",
        "description": "Get all available features (aligned over runs) in the given project-space.",
        "operationId": "getAlignedFeaturesPaged",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to read from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "Zero-based page index (0..N)",
            "required": false,
            "schema": {
              "minimum": 0,
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "size",
            "in": "query",
            "description": "The size of the page to be returned",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer",
              "default": 20
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "msDataAsCosineQuery",
            "in": "query",
            "description": "Returns all fragment spectra in a preprocessed form as used for fast\n                            Cosine/Modified Cosine computation. Gives you spectra compatible with SpectralLibraryMatch\n                            peak assignments and reference spectra.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/AlignedFeatureOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "AlignedFeatures with additional annotations and MS/MS data (if specified).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PagedModelAlignedFeature"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/grouped": {
      "get": {
        "tags": [
          "Features"
        ],
        "summary": "[EXPERIMENTAL] Get features (aligned over runs) by tag group",
        "description": "[EXPERIMENTAL] Get features (aligned over runs) by tag group.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "getAlignedFeaturesByGroupExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to delete from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupName",
            "in": "query",
            "description": "tag group name.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "Zero-based page index (0..N)",
            "required": false,
            "schema": {
              "minimum": 0,
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "size",
            "in": "query",
            "description": "The size of the page to be returned",
            "required": false,
            "schema": {
              "minimum": 1,
              "type": "integer",
              "default": 20
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "optFields",
            "in": "query",
            "description": "set of optional fields to be included. Use \u0027none\u0027 only to override defaults.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/AlignedFeatureOptField"
              },
              "default": [
                "none"
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "tagged features (aligned over runs)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PagedModelAlignedFeature"
                }
              }
            }
          }
        }
      }
    },
    "/api/job-configs": {
      "get": {
        "tags": [
          "Jobs"
        ],
        "summary": "Request all available job configurations",
        "description": "Request all available job configurations",
        "operationId": "getJobConfigs",
        "responses": {
          "200": {
            "description": "list of available {@link JobSubmission JobSubmission}s",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/StoredJobSubmission"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/job-config-names": {
      "get": {
        "tags": [
          "Jobs"
        ],
        "summary": "[DEPRECATED] Get all (non-default) job configuration names\n ",
        "description": "[DEPRECATED] Get all (non-default) job configuration names\n \u003cp\u003e\n [DEPRECATED] Use /job-configs to get all configs with names. This endpoint is based on local file paths and will likely be removed in future versions of this API.",
        "operationId": "getJobConfigNames",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "deprecated": true
      }
    },
    "/api/info": {
      "get": {
        "tags": [
          "Info"
        ],
        "operationId": "getInfo",
        "parameters": [
          {
            "name": "serverInfo",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "updateInfo",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Info"
                }
              }
            }
          }
        }
      }
    },
    "/api/guis": {
      "get": {
        "tags": [
          "Gui"
        ],
        "summary": "Get list of currently running gui windows, managed by this SIRIUS instance.",
        "description": "Get list of currently running gui windows, managed by this SIRIUS instance.\n Note this will not show any Clients that are connected from a separate process!",
        "operationId": "getGuis",
        "responses": {
          "200": {
            "description": "List of GUI windows that are currently managed by this SIRIUS instance.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/GuiInfo"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/default-job-config": {
      "get": {
        "tags": [
          "Jobs"
        ],
        "summary": "Request default job configuration",
        "description": "Request default job configuration",
        "operationId": "getDefaultJobConfig",
        "parameters": [
          {
            "name": "includeConfigMap",
            "in": "query",
            "description": "if true, generic configmap with-defaults will be included",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "moveParametersToConfigMap",
            "in": "query",
            "description": "if true, object-based parameters will be converted to and added to the generic configMap parameters",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "includeCustomDbsForStructureSearch",
            "in": "query",
            "description": "if true, default database selection of structure db search\n                                           spectral library search contains also all available custom DB.\n                                           If No custom dbs are selected, spectral library search is disabled by default.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "{@link JobSubmission JobSubmission} with all parameters set to default values.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobSubmission"
                }
              }
            }
          }
        }
      }
    },
    "/api/databases/included": {
      "get": {
        "tags": [
          "Searchable Databases"
        ],
        "operationId": "getIncludedDatabases",
        "parameters": [
          {
            "name": "includeStats",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SearchableDatabase"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/databases/custom": {
      "get": {
        "tags": [
          "Searchable Databases"
        ],
        "operationId": "getCustomDatabases",
        "parameters": [
          {
            "name": "includeStats",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "includeWithErrors",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SearchableDatabase"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/connection-status": {
      "get": {
        "tags": [
          "Info"
        ],
        "operationId": "getConnectionCheck",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConnectionCheck"
                }
              }
            }
          }
        }
      }
    },
    "/api/account/subscriptions": {
      "get": {
        "tags": [
          "Login and Account"
        ],
        "summary": "Get available subscriptions of the account currently logged in.",
        "description": "Get available subscriptions of the account currently logged in. Fails if not logged in.",
        "operationId": "getSubscriptions",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Subscription"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/account/signUp": {
      "get": {
        "tags": [
          "Login and Account"
        ],
        "summary": "Open SignUp window in system browser and return signUp link.",
        "description": "Open SignUp window in system browser and return signUp link.",
        "operationId": "signUp",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "text/plain;charset\u003dUTF-8": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/api/account/signUpURL": {
      "get": {
        "tags": [
          "Login and Account"
        ],
        "summary": "Get SignUp URL (For signUp via web browser)",
        "description": "Get SignUp URL (For signUp via web browser)",
        "operationId": "getSignUpURL",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "text/plain;charset\u003dUTF-8": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/api/account/openPortal": {
      "get": {
        "tags": [
          "Login and Account"
        ],
        "summary": "Open User portal in browser.",
        "description": "Open User portal in browser. If user is logged in SIRIUS tries to transfer the login state to the browser.",
        "operationId": "openPortal",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/account/isLoggedIn": {
      "get": {
        "tags": [
          "Login and Account"
        ],
        "summary": "Check if a user is logged in.",
        "description": "Check if a user is logged in.",
        "operationId": "isLoggedIn",
        "responses": {
          "200": {
            "description": "true if the user is logged in",
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean"
                }
              }
            }
          }
        }
      }
    },
    "/api/account/": {
      "get": {
        "tags": [
          "Login and Account"
        ],
        "summary": "Get information about the account currently logged in.",
        "description": "Get information about the account currently logged in. Fails if not logged in.",
        "operationId": "getAccountInfo",
        "parameters": [
          {
            "name": "includeSubs",
            "in": "query",
            "description": "include available and active subscriptions in {@link AccountInfo AccountInfo}.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Basic information about the account that has been logged in and its subscriptions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountInfo"
                }
              }
            }
          }
        }
      }
    },
    "/actuator/health": {
      "get": {
        "tags": [
          "Actuator"
        ],
        "summary": "Actuator web endpoint \u0027health\u0027",
        "operationId": "health",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/vnd.spring-boot.actuator.v3+json": {
                "schema": {
                  "type": "object"
                }
              },
              "application/json": {
                "schema": {
                  "type": "object"
                }
              },
              "application/vnd.spring-boot.actuator.v2+json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        }
      }
    },
    "/api/projects/{projectId}/runs/tags/{runId}/{tagName}": {
      "delete": {
        "tags": [
          "Runs"
        ],
        "summary": "[EXPERIMENTAL] Delete tag with the given name from the run with the specified ID in the specified project-space",
        "description": "[EXPERIMENTAL] Delete tag with the given name from the run with the specified ID in the specified project-space.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "removeTagFromRunExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to delete from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "runId",
            "in": "path",
            "description": "run to delete tag from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "tagName",
            "in": "path",
            "description": "name of the tag to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/projects/{projectId}/compounds/tags/{compoundId}/{tagName}": {
      "delete": {
        "tags": [
          "Compounds"
        ],
        "summary": "[EXPERIMENTAL] Delete tag with the given name from the compound (group of ion identities) with the specified ID in the specified project-space",
        "description": "[EXPERIMENTAL] Delete tag with the given name from the compound (group of ion identities) with the specified ID in the specified project-space.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "removeTagFromCompoundExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to delete from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "compoundId",
            "in": "path",
            "description": "compound (group of ion identities) to delete tag from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "tagName",
            "in": "path",
            "description": "name of the tag to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/projects/{projectId}/compounds/statistics/foldchanges": {
      "delete": {
        "tags": [
          "Compound Statistics"
        ],
        "summary": "[EXPERIMENTAL] Delete fold changes",
        "description": "[EXPERIMENTAL] Delete fold changes.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "deleteCompoundFoldChangesExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to delete from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "leftGroupName",
            "in": "query",
            "description": "name of the left group.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "rightGroupName",
            "in": "query",
            "description": "name of the right group.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "aggregation",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/AggregationType"
            }
          },
          {
            "name": "quantification",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/QuantMeasure"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/tags/{alignedFeatureId}/{tagName}": {
      "delete": {
        "tags": [
          "Features"
        ],
        "summary": "[EXPERIMENTAL] Delete tag with the given name from the feature (aligned over runs) with the specified ID in the specified project-space",
        "description": "[EXPERIMENTAL] Delete tag with the given name from the feature (aligned over runs) with the specified ID in the specified project-space.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "removeTagFromAlignedFeatureExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to delete from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alignedFeatureId",
            "in": "path",
            "description": "feature (aligned over runs) to delete tag from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "tagName",
            "in": "path",
            "description": "name of the tag to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/projects/{projectId}/aligned-features/statistics/foldchanges": {
      "delete": {
        "tags": [
          "Feature Statistics"
        ],
        "summary": "[EXPERIMENTAL] Delete fold changes",
        "description": "[EXPERIMENTAL] Delete fold changes.\n \u003cp\u003e\n [EXPERIMENTAL] This endpoint is experimental and not part of the stable API specification. This endpoint can change at any time, even in minor updates.",
        "operationId": "deleteAlignedFeatureFoldChangesExperimental",
        "parameters": [
          {
            "name": "projectId",
            "in": "path",
            "description": "project-space to delete from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "leftGroupName",
            "in": "query",
            "description": "name of the left group.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "rightGroupName",
            "in": "query",
            "description": "name of the right group.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "aggregation",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/AggregationType"
            }
          },
          {
            "name": "quantification",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/QuantMeasure"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "ProjectChangeEvent": {
        "type": "object",
        "properties": {
          "eventType": {
            "$ref": "#/components/schemas/ProjectEventType"
          },
          "projectId": {
            "type": "string"
          },
          "compoundId": {
            "type": "string",
            "nullable": true
          },
          "featuredId": {
            "type": "string",
            "nullable": true
          },
          "formulaId": {
            "type": "string",
            "nullable": true
          },
          "structureInChIKey": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "DataImportEvent": {
        "required": [
          "importedCompoundIds",
          "importedFeatureIds"
        ],
        "type": "object",
        "properties": {
          "importJobId": {
            "type": "string",
            "nullable": true
          },
          "importedCompoundIds": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "importedFeatureIds": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "BackgroundComputationsStateEvent": {
        "required": [
          "affectedJobs",
          "numberOfFinishedJobs",
          "numberOfJobs",
          "numberOfRunningJobs"
        ],
        "type": "object",
        "properties": {
          "affectedJobs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Job"
            }
          },
          "numberOfJobs": {
            "type": "integer",
            "format": "int32"
          },
          "numberOfRunningJobs": {
            "type": "integer",
            "format": "int32"
          },
          "numberOfFinishedJobs": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "ProjectEventType": {
        "type": "string",
        "enum": [
          "PROJECT_OPENED",
          "PROJECT_MOVED",
          "PROJECT_CLOSED",
          "FEATURE_CREATED",
          "FEATURE_UPDATED",
          "FEATURE_DELETED",
          "RESULT_CREATED",
          "RESULT_UPDATED",
          "RESULT_DELETED"
        ]
      },
      "ProjectInfoOptField": {
        "type": "string",
        "nullable": true,
        "enum": [
          "none",
          "compatibilityInfo",
          "sizeInformation"
        ]
      },
      "ProjectInfo": {
        "type": "object",
        "properties": {
          "projectId": {
            "type": "string",
            "description": "a user selected unique name of the project for easy access."
          },
          "location": {
            "type": "string",
            "description": "storage location of the project."
          },
          "description": {
            "type": "string",
            "description": "Description of this project.",
            "nullable": true
          },
          "type": {
            "$ref": "#/components/schemas/ProjectType"
          },
          "compatible": {
            "type": "boolean",
            "description": "Indicates whether computed results (e.g. fingerprints, compounds classes) are compatible with the backend.\n If true project is up-to-date and there are no restrictions regarding usage.\n If false project is incompatible and therefore \"read only\" until the incompatible results have been removed. See updateProject endpoint for further information\n If NULL the information has not been requested.",
            "nullable": true
          },
          "numOfFeatures": {
            "type": "integer",
            "description": "Number of features (aligned over runs) in this project. If NULL, information has not been requested (See OptField \u0027sizeInformation\u0027).",
            "format": "int32",
            "nullable": true
          },
          "numOfCompounds": {
            "type": "integer",
            "description": "Number of compounds (group of ion identities) in this project. If NULL, Information has not been requested (See OptField \u0027sizeInformation\u0027) or might be unavailable for this project type.",
            "format": "int32",
            "nullable": true
          },
          "numOfBytes": {
            "type": "integer",
            "description": "Size in Bytes this project consumes on disk If NULL, Information has not been requested (See OptField \u0027sizeInformation\u0027).",
            "format": "int64",
            "nullable": true
          }
        }
      },
      "ProjectType": {
        "type": "string",
        "nullable": true,
        "enum": [
          "DIRECT_IMPORT",
          "PEAKLISTS",
          "ALIGNED_RUNS",
          "UNALIGNED_RUNS"
        ]
      },
      "TagDefinitionImport": {
        "required": [
          "tagName",
          "valueType"
        ],
        "type": "object",
        "properties": {
          "tagName": {
            "type": "string",
            "description": "Name of this tag defined by this definition (key)"
          },
          "description": {
            "type": "string",
            "description": "A human-readable description about the purpose of this tag.",
            "nullable": true
          },
          "tagType": {
            "type": "string",
            "description": "A simple string based identifier to specify the type/scope/purpose of this tag.",
            "nullable": true
          },
          "valueType": {
            "$ref": "#/components/schemas/ValueType"
          },
          "possibleValues": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "object",
              "nullable": true
            }
          },
          "minValue": {
            "type": "object",
            "nullable": true
          },
          "maxValue": {
            "type": "object",
            "nullable": true
          }
        }
      },
      "ValueType": {
        "type": "string",
        "enum": [
          "NONE",
          "BOOLEAN",
          "INTEGER",
          "REAL",
          "TEXT",
          "DATE",
          "TIME"
        ]
      },
      "TagDefinition": {
        "required": [
          "tagName",
          "valueType"
        ],
        "type": "object",
        "properties": {
          "tagName": {
            "type": "string",
            "description": "Name of this tag defined by this definition (key)"
          },
          "description": {
            "type": "string",
            "description": "A human-readable description about the purpose of this tag.",
            "nullable": true
          },
          "tagType": {
            "type": "string",
            "description": "A simple string based identifier to specify the type/scope/purpose of this tag.",
            "nullable": true
          },
          "valueType": {
            "$ref": "#/components/schemas/ValueType"
          },
          "possibleValues": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "object",
              "nullable": true
            }
          },
          "minValue": {
            "type": "object",
            "nullable": true
          },
          "maxValue": {
            "type": "object",
            "nullable": true
          },
          "editable": {
            "type": "boolean"
          }
        }
      },
      "Tag": {
        "required": [
          "tagName"
        ],
        "type": "object",
        "properties": {
          "tagName": {
            "type": "string",
            "description": "Name of the tag as defined by the corresponding TagDefinition\n Links tag object to their definition."
          },
          "value": {
            "type": "object",
            "description": "Optional value of the tag.\n \u003cp\u003e\n Generic value of the tag as defined by the corresponding TagDefinition.\n Can be Integer, Double, Boolean and String, whereas String values can represent Text, Date (yyyy-MM-dd) or Time (HH:mm:ss).",
            "nullable": true
          }
        }
      },
      "SampleTypeFoldChangeRequest": {
        "type": "object",
        "properties": {
          "sampleRunIds": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "blankRunIds": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "controlRunIds": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "JobOptField": {
        "type": "string",
        "nullable": true,
        "enum": [
          "none",
          "command",
          "progress",
          "affectedIds"
        ]
      },
      "Job": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier to access the job via the API"
          },
          "command": {
            "type": "string",
            "description": "Command string of the executed Task",
            "nullable": true
          },
          "progress": {
            "$ref": "#/components/schemas/JobProgress"
          },
          "affectedCompoundIds": {
            "type": "array",
            "description": "List of compoundIds that are affected by this job.\n This lis will also contain compoundIds where not all features of the compound are affected by the job.\n If this job is creating compounds (e.g. data import jobs) this value will be NULL until the jobs has finished",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "affectedAlignedFeatureIds": {
            "type": "array",
            "description": "List of alignedFeatureIds that are affected by this job.\n If this job is creating features (e.g. data import jobs) this value will be NULL until the jobs has finished",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "jobEffect": {
            "$ref": "#/components/schemas/JobEffect"
          }
        },
        "description": "Identifier created by the SIRIUS Nightsky API for a newly created Job.\n Object can be enriched with Job status/progress information ({@link JobProgress JobProgress}) and/or Job command information.\n This is a return value of the API. So nullable values can also be NOT_REQUIRED to allow for easy removal."
      },
      "JobEffect": {
        "type": "string",
        "nullable": true,
        "enum": [
          "IMPORT",
          "COMPUTATION",
          "DELETION"
        ]
      },
      "JobProgress": {
        "type": "object",
        "properties": {
          "indeterminate": {
            "type": "boolean",
            "description": "Is the progress indeterminate or not",
            "nullable": true
          },
          "state": {
            "$ref": "#/components/schemas/JobState"
          },
          "currentProgress": {
            "type": "integer",
            "description": "Current progress value of the job.",
            "format": "int64",
            "nullable": true
          },
          "maxProgress": {
            "type": "integer",
            "description": "Progress value to reach (might also change during execution)",
            "format": "int64",
            "nullable": true
          },
          "message": {
            "type": "string",
            "description": "Progress information and warnings.",
            "nullable": true
          },
          "errorMessage": {
            "type": "string",
            "description": "Error message if the job did not finish successfully failed.",
            "nullable": true
          }
        },
        "description": "Progress information of a computation job that has already been submitted to SIRIUS.\n if  currentProgress \u003d\u003d maxProgress job is finished and should change to state done soon.\n if a job is DONE all results can be accessed via the Project-Spaces api.",
        "nullable": true
      },
      "JobState": {
        "type": "string",
        "enum": [
          "WAITING",
          "READY",
          "QUEUED",
          "SUBMITTED",
          "RUNNING",
          "CANCELED",
          "FAILED",
          "DONE"
        ]
      },
      "AggregationType": {
        "type": "string",
        "enum": [
          "AVG",
          "MIN",
          "MAX"
        ]
      },
      "QuantMeasure": {
        "type": "string",
        "enum": [
          "APEX_INTENSITY",
          "AREA_UNDER_CURVE"
        ]
      },
      "SearchableDatabaseParameters": {
        "type": "object",
        "properties": {
          "displayName": {
            "type": "string",
            "description": "display name of the database\n Should be short",
            "nullable": true
          },
          "location": {
            "type": "string",
            "description": "Storage location of user database\n Might be NULL for non-user databases or if default location is used.",
            "nullable": true
          },
          "matchRtOfReferenceSpectra": {
            "type": "boolean",
            "description": "Indicates whether this database shall be used to use retention time information for library matching.\n Typically used for in-house spectral libraries that have been measured on",
            "nullable": true,
            "default": false
          }
        }
      },
      "SearchableDatabase": {
        "required": [
          "customDb",
          "databaseId",
          "searchable",
          "updateNeeded"
        ],
        "type": "object",
        "properties": {
          "displayName": {
            "type": "string",
            "description": "display name of the database\n Should be short",
            "nullable": true
          },
          "location": {
            "type": "string",
            "description": "Storage location of user database\n Might be NULL for non-user databases or if default location is used.",
            "nullable": true
          },
          "matchRtOfReferenceSpectra": {
            "type": "boolean",
            "description": "Indicates whether this database shall be used to use retention time information for library matching.\n Typically used for in-house spectral libraries that have been measured on",
            "nullable": true,
            "default": false
          },
          "databaseId": {
            "type": "string",
            "description": "A unique identifier or name of the database.\n Should only contain file path and url save characters\n For user databases this is usually the file name."
          },
          "customDb": {
            "type": "boolean",
            "description": "Indicates whether the database is a user managed custom database or if it is a\n database that is included in SIRIUS which cannot be modified."
          },
          "searchable": {
            "type": "boolean",
            "description": "True when this database can be used as a search parameter.\n False if the database is just an additional filter that can be applied after search."
          },
          "dbDate": {
            "type": "string",
            "description": "Date on which the data was imported / database was created.",
            "nullable": true
          },
          "dbVersion": {
            "type": "integer",
            "description": "database schema version",
            "format": "int32",
            "nullable": true
          },
          "updateNeeded": {
            "type": "boolean",
            "description": "If true the database version is outdated and the database needs to be updated or re-imported before it can be used."
          },
          "numberOfStructures": {
            "type": "integer",
            "description": "Number of unique compounds available in this database.",
            "format": "int64",
            "nullable": true
          },
          "numberOfFormulas": {
            "type": "integer",
            "description": "Number of different molecular formulas available in this database.",
            "format": "int64",
            "nullable": true
          },
          "numberOfReferenceSpectra": {
            "type": "integer",
            "description": "Number of reference spectra available in this database",
            "format": "int64",
            "nullable": true
          },
          "errorMessage": {
            "type": "string",
            "description": "Error message if the database could not be loaded",
            "nullable": true
          }
        }
      },
      "AccountInfo": {
        "type": "object",
        "properties": {
          "userID": {
            "type": "string"
          },
          "username": {
            "type": "string",
            "nullable": true
          },
          "userEmail": {
            "type": "string"
          },
          "gravatarURL": {
            "type": "string",
            "nullable": true
          },
          "subscriptions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Subscription"
            }
          },
          "activeSubscriptionId": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "Subscription": {
        "type": "object",
        "properties": {
          "sid": {
            "type": "string",
            "description": "Unique identifier of this subscription"
          },
          "subscriberId": {
            "type": "string",
            "description": "ID of the owner of the subscription.\n This can be the ID of any SubscriptionOwner (e.g.  Group or  User)\n depending on the level on which a subscription should be is valid."
          },
          "subscriberName": {
            "type": "string",
            "description": "Optional name of the owner of this subscription",
            "nullable": true
          },
          "expirationDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "startDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "countQueries": {
            "type": "boolean",
            "nullable": true
          },
          "instanceLimit": {
            "type": "integer",
            "description": "Limit of instances (features) that can be computed with this subscription",
            "format": "int32",
            "nullable": true
          },
          "instanceHashRecordingTime": {
            "type": "integer",
            "description": "Hash is used to allow recomputing identical data without increasing counted instances (features).\n The recording time is the amount of time an instance is memorized is",
            "format": "int32",
            "nullable": true
          },
          "maxQueriesPerInstance": {
            "type": "integer",
            "description": "Maximum number of queries (e.g. prediction) that can be performed\n for one instance before it is counted another time.",
            "format": "int32",
            "nullable": true
          },
          "maxUserAccounts": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "serviceUrl": {
            "type": "string"
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "tos": {
            "type": "string",
            "nullable": true
          },
          "pp": {
            "type": "string",
            "nullable": true
          }
        }
      },
      "Canopus": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "tags whether the tool is enabled"
          }
        },
        "description": "User/developer friendly parameter subset for the CANOPUS tool\n CANOPUS is parameter free, so this Object is just a flag that canopus should be executed.\n Needs results from FingerprintPrediction Tool",
        "nullable": true
      },
      "ConfidenceMode": {
        "type": "string",
        "nullable": true,
        "enum": [
          "OFF",
          "EXACT",
          "APPROXIMATE"
        ]
      },
      "FingerprintPrediction": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "tags whether the tool is enabled"
          },
          "useScoreThreshold": {
            "type": "boolean",
            "description": "If true, an adaptive soft threshold will be applied to only compute Fingerprints for promising formula candidates\n Enabling is highly recommended.",
            "nullable": true
          },
          "alwaysPredictHighRefMatches": {
            "type": "boolean",
            "description": "If true Fingerprint/Classes/Structures will be predicted for formulas candidates with\n reference spectrum similarity \u003e Sirius.minReferenceMatchScoreToInject will be predicted no matter which\n score threshold rules apply.\n If NULL default value will be used.",
            "nullable": true
          }
        },
        "description": "User/developer friendly parameter subset for the CSI:FingerID Fingerprint tool\n Needs results from Formula/SIRIUS Tool",
        "nullable": true
      },
      "InstrumentProfile": {
        "type": "string",
        "description": "Select the profile that is the closest to your instrumental setup. If nothing fits, use QTOF.",
        "nullable": true,
        "enum": [
          "QTOF",
          "ORBITRAP"
        ]
      },
      "IsotopeMs2Strategy": {
        "type": "string",
        "nullable": true,
        "enum": [
          "IGNORE",
          "FILTER",
          "SCORE"
        ]
      },
      "JobSubmission": {
        "type": "object",
        "properties": {
          "compoundIds": {
            "type": "array",
            "description": "Compounds that should be the input for this Job\n Will be converted to the respective alignedFeatureIds for computation.\n\n At least one compoundId or alignedFeatureId needs to be specified.",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "alignedFeatureIds": {
            "type": "array",
            "description": "Features (aligned over runs) that should be the input for this Job\n\n At least one compoundId or alignedFeatureId needs to be specified.",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "fallbackAdducts": {
            "type": "array",
            "description": "Describes how to deal with Adducts: Fallback adducts are considered if the auto detection did not find any indication for an ion mode.\n Pos Examples: [M+H]+,[M]+,[M+K]+,[M+Na]+,[M+H-H2O]+,[M+Na2-H]+,[M+2K-H]+,[M+NH4]+,[M+H3O]+,[M+MeOH+H]+,[M+ACN+H]+,[M+2ACN+H]+,[M+IPA+H]+,[M+ACN+Na]+,[M+DMSO+H]+\n Neg Examples: [M-H]-,[M]-,[M+K-2H]-,[M+Cl]-,[M-H2O-H]-,[M+Na-2H]-,M+FA-H]-,[M+Br]-,[M+HAc-H]-,[M+TFA-H]-,[M+ACN-H]-",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "enforcedAdducts": {
            "type": "array",
            "description": "Describes how to deal with Adducts:  Enforced adducts that are always considered.\n Pos Examples: [M+H]+,[M]+,[M+K]+,[M+Na]+,[M+H-H2O]+,[M+Na2-H]+,[M+2K-H]+,[M+NH4]+,[M+H3O]+,[M+MeOH+H]+,[M+ACN+H]+,[M+2ACN+H]+,[M+IPA+H]+,[M+ACN+Na]+,[M+DMSO+H]+\n Neg Examples: [M-H]-,[M]-,[M+K-2H]-,[M+Cl]-,[M-H2O-H]-,[M+Na-2H]-,M+FA-H]-,[M+Br]-,[M+HAc-H]-,[M+TFA-H]-,[M+ACN-H]-",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "detectableAdducts": {
            "type": "array",
            "description": "Describes how to deal with Adducts: Detectable adducts which are only considered if there is an indication in the MS1 scan (e.g. correct mass delta).\n Pos Examples: [M+H]+,[M]+,[M+K]+,[M+Na]+,[M+H-H2O]+,[M+Na2-H]+,[M+2K-H]+,[M+NH4]+,[M+H3O]+,[M+MeOH+H]+,[M+ACN+H]+,[M+2ACN+H]+,[M+IPA+H]+,[M+ACN+Na]+,[M+DMSO+H]+\n Neg Examples: [M-H]-,[M]-,[M+K-2H]-,[M+Cl]-,[M-H2O-H]-,[M+Na-2H]-,M+FA-H]-,[M+Br]-,[M+HAc-H]-,[M+TFA-H]-,[M+ACN-H]-",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "recompute": {
            "type": "boolean",
            "description": "Indicate if already existing result for a tool to be executed should be overwritten or not.",
            "nullable": true
          },
          "spectraSearchParams": {
            "$ref": "#/components/schemas/SpectralLibrarySearch"
          },
          "formulaIdParams": {
            "$ref": "#/components/schemas/Sirius"
          },
          "zodiacParams": {
            "$ref": "#/components/schemas/Zodiac"
          },
          "fingerprintPredictionParams": {
            "$ref": "#/components/schemas/FingerprintPrediction"
          },
          "canopusParams": {
            "$ref": "#/components/schemas/Canopus"
          },
          "structureDbSearchParams": {
            "$ref": "#/components/schemas/StructureDbSearch"
          },
          "msNovelistParams": {
            "$ref": "#/components/schemas/MsNovelist"
          },
          "configMap": {
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "nullable": true
            },
            "description": "As an alternative to the object based parameters, this map allows to store key value pairs\n of ALL SIRIUS parameters. All possible parameters can be retrieved from SIRIUS via the respective endpoint.",
            "nullable": true
          }
        },
        "description": "Object to submit a job to be executed by SIRIUS"
      },
      "MsNovelist": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "tags whether the tool is enabled"
          },
          "numberOfCandidateToPredict": {
            "type": "integer",
            "description": "Number of structure candidates to be predicted by MsNovelist.\n Max Value 128. Values \u003e 128 will be set to 128.\n Actual number of returned candidate might be lower du to duplicates being created by MsNovelist.",
            "format": "int32",
            "nullable": true
          }
        },
        "nullable": true
      },
      "Sirius": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "tags whether the tool is enabled"
          },
          "profile": {
            "$ref": "#/components/schemas/InstrumentProfile"
          },
          "numberOfCandidates": {
            "type": "integer",
            "description": "Number of formula candidates to keep as result list (Formula Candidates).",
            "format": "int32",
            "nullable": true
          },
          "numberOfCandidatesPerIonization": {
            "type": "integer",
            "description": "Use this parameter if you want to force SIRIUS to report at least\n NumberOfCandidatesPerIonization results per ionization.\n if \u003c\u003d 0, this parameter will have no effect and just the top\n NumberOfCandidates results will be reported.",
            "format": "int32",
            "nullable": true
          },
          "massAccuracyMS2ppm": {
            "type": "number",
            "description": "Maximum allowed mass deviation. Only molecular formulas within this mass window are considered.",
            "format": "double",
            "nullable": true
          },
          "isotopeMs2Settings": {
            "$ref": "#/components/schemas/IsotopeMs2Strategy"
          },
          "filterByIsotopePattern": {
            "type": "boolean",
            "description": "When filtering is enabled, molecular formulas are excluded if their theoretical isotope pattern does not match the theoretical one, even if their MS/MS pattern has high score.",
            "nullable": true
          },
          "enforceElGordoFormula": {
            "type": "boolean",
            "description": "El Gordo may predict that an MS/MS spectrum is a lipid spectrum. If enabled, the corresponding molecular formula will be enforeced as molecular formula candidate.",
            "nullable": true
          },
          "performBottomUpSearch": {
            "type": "boolean",
            "description": "If true, molecular formula generation via bottom up search is enabled.",
            "nullable": true
          },
          "performDenovoBelowMz": {
            "type": "number",
            "description": "Specifies the m/z below which de novo molecular formula generation is enabled. Set to 0 to disable de novo molecular formula generation.",
            "format": "double",
            "nullable": true
          },
          "formulaSearchDBs": {
            "type": "array",
            "description": "List Structure database to extract molecular formulas from to reduce formula search space.\n SIRIUS is quite good at de novo formula annotation, so only enable if you have a good reason.",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "applyFormulaConstraintsToDBAndBottomUpSearch": {
            "type": "boolean",
            "description": "By default, the formula (element) constraints are only applied to de novo molecular formula generation.\n If true, the constraints are as well applied to database search and bottom up search.",
            "nullable": true
          },
          "enforcedFormulaConstraints": {
            "type": "string",
            "description": "These configurations hold the information how to autodetect elements based on the given formula constraints.\n Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.\n \u003cp\u003e\n Enforced: Enforced elements are always considered",
            "nullable": true
          },
          "fallbackFormulaConstraints": {
            "type": "string",
            "description": "These configurations hold the information how to autodetect elements based on the given formula constraints.\n Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.\n \u003cp\u003e\n Fallback: Fallback elements are used, if the auto-detection fails (e.g. no isotope pattern available)",
            "nullable": true
          },
          "detectableElements": {
            "type": "array",
            "description": "These configurations hold the information how to autodetect elements based on the given formula constraints.\n Note: If the compound is already assigned to a specific molecular formula, this annotation is ignored.\n \u003cp\u003e\n Detectable: Detectable elements are added to the chemical alphabet, if there are indications for them (e.g. in isotope pattern)",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "ilpTimeout": {
            "$ref": "#/components/schemas/Timeout"
          },
          "useHeuristic": {
            "$ref": "#/components/schemas/UseHeuristic"
          },
          "injectSpecLibMatchFormulas": {
            "type": "boolean",
            "description": "If true formula candidates that belong to spectral library matches above a certain threshold will\n we inject/preserved for further analyses no matter which score they have or which filter is applied",
            "nullable": true
          },
          "minScoreToInjectSpecLibMatch": {
            "type": "number",
            "description": "Similarity Threshold to inject formula candidates no matter which score/rank they have or which filter settings are applied.\n If threshold \u003e\u003d 0 formulas candidates with reference spectrum similarity above the threshold will be injected.",
            "format": "double",
            "nullable": true
          },
          "minPeaksToInjectSpecLibMatch": {
            "type": "integer",
            "description": "Matching peaks threshold to inject formula candidates no matter which score they have or which filter is applied.",
            "format": "int32",
            "nullable": true
          }
        },
        "description": "User/developer friendly parameter subset for the Formula/SIRIUS tool\n Can use results from Spectral library search tool.",
        "nullable": true
      },
      "SpectralLibrarySearch": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "tags whether the tool is enabled"
          },
          "spectraSearchDBs": {
            "type": "array",
            "description": "Structure Databases with Reference spectra to search in.\n \u003cp\u003e\n Defaults to BIO + Custom Databases. Possible values are available to Database API.",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "precursorDeviationPpm": {
            "type": "number",
            "description": "Maximum allowed mass deviation in ppm for matching the precursor. If not specified, the same value as for the peaks is used.",
            "format": "double",
            "nullable": true
          },
          "minSimilarity": {
            "type": "number",
            "description": "Minimal spectral similarity of a spectral match to be considered a hit.",
            "format": "float",
            "nullable": true
          },
          "minNumOfPeaks": {
            "type": "integer",
            "description": "Minimal number of matching peaks of a spectral match to be considered a hit.",
            "format": "int32",
            "nullable": true
          },
          "enableAnalogueSearch": {
            "type": "boolean",
            "description": "Enable analogue search in addition to the identity spectral library search"
          },
          "minSimilarityAnalogue": {
            "type": "number",
            "description": "Minimal spectral similarity of a spectral match to be considered an analogue hit.",
            "format": "float",
            "nullable": true
          },
          "minNumOfPeaksAnalogue": {
            "type": "integer",
            "description": "Minimal number of matching peaks of a spectral match to be considered an analogue hit.",
            "format": "int32",
            "nullable": true
          },
          "scoring": {
            "$ref": "#/components/schemas/SpectralMatchingType"
          },
          "peakDeviationPpm": {
            "type": "number",
            "description": "NO LONGER SUPPORTED (IGNORED)\n Maximum allowed mass deviation in ppm for matching peaks.",
            "format": "double",
            "nullable": true,
            "deprecated": true
          }
        },
        "description": "User/developer friendly parameter subset for the Spectral library search tool.",
        "nullable": true
      },
      "SpectralMatchingType": {
        "type": "string",
        "nullable": true,
        "enum": [
          "INTENSITY",
          "GAUSSIAN",
          "MODIFIED_COSINE",
          "FAST_COSINE"
        ]
      },
      "StructureDbSearch": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "tags whether the tool is enabled"
          },
          "structureSearchDBs": {
            "type": "array",
            "description": "Structure databases to search in, If expansive search is enabled this DB selection will be expanded to PubChem\n if not high confidence hit was found in the selected databases.\n \u003cp\u003e\n Defaults to BIO + Custom Databases. Possible values are available to Database API.",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "tagStructuresWithLipidClass": {
            "type": "boolean",
            "description": "Candidates matching the lipid class estimated by El Gordo will be tagged.\n The lipid class will only be available if El Gordo predicts that the MS/MS is a lipid spectrum.\n If this parameter is set to \u0027false\u0027 El Gordo will still be executed and e.g. improve the fragmentation\n tree, but the matching structure candidates will not be tagged if they match lipid class.",
            "nullable": true
          },
          "expansiveSearchConfidenceMode": {
            "$ref": "#/components/schemas/ConfidenceMode"
          }
        },
        "description": "User/developer friendly parameter subset for the CSI:FingerID structure db search tool.\n Needs results from FingerprintPrediction and Canopus Tool.\n Non-Null parameters in this Object well override their equivalent value in the config map.",
        "nullable": true
      },
      "Timeout": {
        "type": "object",
        "properties": {
          "numberOfSecondsPerDecomposition": {
            "type": "integer",
            "format": "int32"
          },
          "numberOfSecondsPerInstance": {
            "type": "integer",
            "format": "int32"
          }
        },
        "nullable": true
      },
      "UseHeuristic": {
        "type": "object",
        "properties": {
          "useHeuristicAboveMz": {
            "type": "integer",
            "format": "int32"
          },
          "useOnlyHeuristicAboveMz": {
            "type": "integer",
            "format": "int32"
          }
        },
        "nullable": true
      },
      "Zodiac": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "tags whether the tool is enabled"
          },
          "consideredCandidatesAt300Mz": {
            "type": "integer",
            "description": "Maximum number of candidate molecular formulas (fragmentation trees computed by SIRIUS) per compound which are considered by ZODIAC for compounds below 300 m/z.",
            "format": "int32",
            "nullable": true
          },
          "consideredCandidatesAt800Mz": {
            "type": "integer",
            "description": "Maximum number of candidate molecular formulas (fragmentation trees computed by SIRIUS) per compound which are considered by ZODIAC for compounds above 800 m/z.",
            "format": "int32",
            "nullable": true
          },
          "runInTwoSteps": {
            "type": "boolean",
            "description": "As default ZODIAC runs a 2-step approach. First running \u0027good quality compounds\u0027 only, and afterwards including the remaining.",
            "nullable": true
          },
          "edgeFilterThresholds": {
            "$ref": "#/components/schemas/ZodiacEdgeFilterThresholds"
          },
          "gibbsSamplerParameters": {
            "$ref": "#/components/schemas/ZodiacEpochs"
          },
          "librarySearchAnchors": {
            "$ref": "#/components/schemas/ZodiacLibraryScoring"
          },
          "analogueSearchAnchors": {
            "$ref": "#/components/schemas/ZodiacAnalogueNodes"
          }
        },
        "description": "User/developer friendly parameter subset for the ZODIAC tool (Network base molecular formula re-ranking).\n Needs results from Formula/SIRIUS Tool",
        "nullable": true
      },
      "ZodiacAnalogueNodes": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          },
          "minSimilarity": {
            "type": "number",
            "format": "double"
          },
          "minSharedPeaks": {
            "type": "integer",
            "format": "int32"
          }
        },
        "nullable": true
      },
      "ZodiacEdgeFilterThresholds": {
        "type": "object",
        "properties": {
          "thresholdFilter": {
            "type": "number",
            "format": "double"
          },
          "minLocalCandidates": {
            "type": "integer",
            "format": "int32"
          },
          "minLocalConnections": {
            "type": "integer",
            "format": "int32"
          }
        },
        "nullable": true
      },
      "ZodiacEpochs": {
        "type": "object",
        "properties": {
          "iterations": {
            "type": "integer",
            "format": "int32"
          },
          "burnInPeriod": {
            "type": "integer",
            "format": "int32"
          },
          "numberOfMarkovChains": {
            "type": "integer",
            "format": "int32"
          }
        },
        "nullable": true
      },
      "ZodiacLibraryScoring": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          },
          "minSimilarity": {
            "type": "number",
            "format": "double"
          }
        },
        "nullable": true
      },
      "CommandSubmission": {
        "required": [
          "command"
        ],
        "type": "object",
        "properties": {
          "compoundIds": {
            "type": "array",
            "description": "Compounds that should be the input for this Job\n Will be converted to the respective alignedFeatureIds for computation.\n\n At least one compoundId or alignedFeatureId needs to be specified.",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "alignedFeatureIds": {
            "type": "array",
            "description": "Features (aligned over runs) that should be the input for this Job\n\n At least one compoundId or alignedFeatureId needs to be specified.",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "command": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ImportResult": {
        "required": [
          "affectedAlignedFeatureIds",
          "affectedCompoundIds"
        ],
        "type": "object",
        "properties": {
          "affectedCompoundIds": {
            "type": "array",
            "description": "List of compoundIds that have been imported.",
            "items": {
              "type": "string"
            }
          },
          "affectedAlignedFeatureIds": {
            "type": "array",
            "description": "List of alignedFeatureIds that have been imported..",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "LcmsSubmissionParameters": {
        "type": "object",
        "properties": {
          "alignLCMSRuns": {
            "type": "boolean",
            "description": "Specifies whether LC/MS runs should be aligned",
            "default": true
          }
        }
      },
      "TagGroup": {
        "type": "object",
        "properties": {
          "groupName": {
            "type": "string",
            "description": "Name of this Grouping query."
          },
          "luceneQuery": {
            "type": "string",
            "description": "Query used to group the entities in lucene format."
          },
          "groupType": {
            "type": "string"
          }
        }
      },
      "BasicSpectrum": {
        "required": [
          "cosineQuery",
          "peaks"
        ],
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Optional Displayable name of this spectrum.",
            "nullable": true
          },
          "msLevel": {
            "type": "integer",
            "description": "MS level of the measured spectrum.\n Artificial spectra with no msLevel (e.g. Simulated Isotope patterns) use null or zero",
            "format": "int32",
            "nullable": true
          },
          "collisionEnergy": {
            "type": "string",
            "description": "Collision energy used for MS/MS spectra\n Null for spectra where collision energy is not applicable",
            "nullable": true
          },
          "instrument": {
            "type": "string",
            "description": "Instrument information.",
            "nullable": true
          },
          "precursorMz": {
            "type": "number",
            "description": "Precursor m/z of the MS/MS spectrum\n Null for spectra where precursor m/z is not applicable",
            "format": "double",
            "nullable": true
          },
          "scanNumber": {
            "type": "integer",
            "description": "Scan number of the spectrum.\n Might be null for artificial spectra with no scan number (e.g. Simulated Isotope patterns or merged spectra)",
            "format": "int32",
            "nullable": true
          },
          "cosineQuery": {
            "type": "boolean",
            "description": "True if spectrum is in cosine query normalized format.\n Such spectrum is compatible with SpectralLibraryMatch peak assignments to reference spectra.",
            "default": false
          },
          "precursorPeak": {
            "$ref": "#/components/schemas/SimplePeak"
          },
          "peaks": {
            "type": "array",
            "description": "The peaks of this spectrum which might contain additional annotations such as molecular formulas.",
            "items": {
              "$ref": "#/components/schemas/SimplePeak"
            }
          },
          "absIntensityFactor": {
            "type": "number",
            "description": "Factor to convert relative intensities to absolute intensities.\n Might be null or 1 for spectra where absolute intensities are not available (E.g. artificial or merged spectra)",
            "format": "double",
            "nullable": true
          }
        },
        "nullable": true
      },
      "CompoundImport": {
        "required": [
          "features"
        ],
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Some (optional) human-readable name",
            "nullable": true
          },
          "features": {
            "type": "array",
            "description": "The features this compound consists of.",
            "items": {
              "$ref": "#/components/schemas/FeatureImport"
            }
          }
        }
      },
      "DataQuality": {
        "type": "string",
        "nullable": true,
        "enum": [
          "NOT_APPLICABLE",
          "LOWEST",
          "BAD",
          "DECENT",
          "GOOD"
        ]
      },
      "FeatureImport": {
        "required": [
          "charge",
          "ionMass"
        ],
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "nullable": true
          },
          "externalFeatureId": {
            "type": "string",
            "description": "Externally provided FeatureId (by some preprocessing tool). This FeatureId is NOT used by SIRIUS but is stored to ease mapping information back to the source.",
            "nullable": true
          },
          "ionMass": {
            "type": "number",
            "format": "double"
          },
          "charge": {
            "type": "integer",
            "format": "int32"
          },
          "detectedAdducts": {
            "uniqueItems": true,
            "type": "array",
            "description": "Detected adducts of this feature. Can be NULL or empty if no adducts are known.",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "rtStartSeconds": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "rtEndSeconds": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "rtApexSeconds": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "dataQuality": {
            "$ref": "#/components/schemas/DataQuality"
          },
          "mergedMs1": {
            "$ref": "#/components/schemas/BasicSpectrum"
          },
          "ms1Spectra": {
            "type": "array",
            "description": "List of MS1Spectra belonging to this feature. These spectra will be merged an only a representative\n mergedMs1 spectrum will be stored in SIRIUS. At least one of these spectra should contain the\n isotope pattern of the precursor ion.\n Note: Will be ignored if \u0027mergedMs1\u0027 is given.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/BasicSpectrum"
            }
          },
          "ms2Spectra": {
            "type": "array",
            "description": "List of MS/MS spectra that belong to this feature.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/BasicSpectrum"
            }
          }
        },
        "description": "Represents an (aligned) feature to be imported into a SIRIUS project.\n At least one of the Mass Spec data sources (e.g. mergedMs1, ms1Spectra, ms2Spectra) needs to be given.\n Otherwise, the import will fail."
      },
      "SimplePeak": {
        "type": "object",
        "properties": {
          "mz": {
            "type": "number",
            "format": "double"
          },
          "intensity": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "CompoundOptField": {
        "type": "string",
        "nullable": true,
        "enum": [
          "none",
          "consensusAnnotations",
          "consensusAnnotationsDeNovo",
          "customAnnotations",
          "tags"
        ]
      },
      "AlignedFeatureOptField": {
        "type": "string",
        "nullable": true,
        "enum": [
          "none",
          "msData",
          "topAnnotations",
          "topAnnotationsDeNovo",
          "computedTools",
          "tags"
        ]
      },
      "AlignedFeature": {
        "required": [
          "charge",
          "detectedAdducts"
        ],
        "type": "object",
        "properties": {
          "alignedFeatureId": {
            "type": "string"
          },
          "compoundId": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "externalFeatureId": {
            "type": "string",
            "description": "Externally provided FeatureId (e.g. by some preprocessing tool).\n This FeatureId is NOT used by SIRIUS but is stored to ease mapping information back to the source."
          },
          "ionMass": {
            "type": "number",
            "format": "double"
          },
          "charge": {
            "type": "integer",
            "description": "Ion mode (charge) this feature has been measured in.",
            "format": "int32"
          },
          "detectedAdducts": {
            "uniqueItems": true,
            "type": "array",
            "description": "Adducts of this feature that have been detected during preprocessing.",
            "items": {
              "type": "string"
            }
          },
          "rtStartSeconds": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "rtEndSeconds": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "rtApexSeconds": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "quality": {
            "$ref": "#/components/schemas/DataQuality"
          },
          "hasMs1": {
            "type": "boolean",
            "description": "If true, the feature has at lease one MS1 spectrum"
          },
          "hasMsMs": {
            "type": "boolean",
            "description": "If true, the feature has at lease one MS/MS spectrum"
          },
          "msData": {
            "$ref": "#/components/schemas/MsData"
          },
          "topAnnotations": {
            "$ref": "#/components/schemas/FeatureAnnotations"
          },
          "topAnnotationsDeNovo": {
            "$ref": "#/components/schemas/FeatureAnnotations"
          },
          "computing": {
            "type": "boolean",
            "description": "Write lock for this feature. If the feature is locked no write operations are possible.\n True if any computation is modifying this feature or its results"
          },
          "computedTools": {
            "$ref": "#/components/schemas/ComputedSubtools"
          },
          "tags": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/Tag"
            },
            "description": "Key: tagName, value: tag",
            "nullable": true
          }
        },
        "description": "The AlignedFeature contains the ID of a feature (aligned over runs) together with some read-only information\n that might be displayed in some summary view."
      },
      "AnnotatedPeak": {
        "type": "object",
        "properties": {
          "mz": {
            "type": "number",
            "format": "double"
          },
          "intensity": {
            "type": "number",
            "format": "double"
          },
          "peakAnnotation": {
            "$ref": "#/components/schemas/PeakAnnotation"
          }
        }
      },
      "AnnotatedSpectrum": {
        "required": [
          "cosineQuery",
          "peaks"
        ],
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Optional Displayable name of this spectrum.",
            "nullable": true
          },
          "msLevel": {
            "type": "integer",
            "description": "MS level of the measured spectrum.\n Artificial spectra with no msLevel (e.g. Simulated Isotope patterns) use null or zero",
            "format": "int32",
            "nullable": true
          },
          "collisionEnergy": {
            "type": "string",
            "description": "Collision energy used for MS/MS spectra\n Null for spectra where collision energy is not applicable",
            "nullable": true
          },
          "instrument": {
            "type": "string",
            "description": "Instrument information.",
            "nullable": true
          },
          "precursorMz": {
            "type": "number",
            "description": "Precursor m/z of the MS/MS spectrum\n Null for spectra where precursor m/z is not applicable",
            "format": "double",
            "nullable": true
          },
          "scanNumber": {
            "type": "integer",
            "description": "Scan number of the spectrum.\n Might be null for artificial spectra with no scan number (e.g. Simulated Isotope patterns or merged spectra)",
            "format": "int32",
            "nullable": true
          },
          "cosineQuery": {
            "type": "boolean",
            "description": "True if spectrum is in cosine query normalized format.\n Such spectrum is compatible with SpectralLibraryMatch peak assignments to reference spectra.",
            "default": false
          },
          "precursorPeak": {
            "$ref": "#/components/schemas/SimplePeak"
          },
          "peaks": {
            "type": "array",
            "description": "The peaks of this spectrum which might contain additional annotations such as molecular formulas.",
            "items": {
              "$ref": "#/components/schemas/AnnotatedPeak"
            }
          },
          "absIntensityFactor": {
            "type": "number",
            "description": "Factor to convert relative intensities to absolute intensities.\n Might be null or 1 for spectra where absolute intensities are not available (E.g. artificial or merged spectra)",
            "format": "double",
            "nullable": true
          },
          "spectrumAnnotation": {
            "$ref": "#/components/schemas/SpectrumAnnotation"
          }
        },
        "description": "Spectrum model with peak annotations based on the fragmentation tree and Epimetheus substructure annotations.\n Molecular formula and adduct of the spectrum are identical to the ones of the corresponding molecular formula candidate and FragmentationTree.\n Fragment molecular formulas and adducts correspond to the FragmentationTree\u0027s FragmentNodes",
        "nullable": true
      },
      "BinaryFingerprint": {
        "type": "object",
        "properties": {
          "bitsSet": {
            "type": "array",
            "description": "Array that contains all RELATIVE indices (masked FP) of bits that are set (are 1)",
            "items": {
              "type": "integer",
              "format": "int32"
            }
          },
          "length": {
            "type": "integer",
            "description": "Size of the fingerprint (masked fp), e.g. to reconstruct the binary array from the array of set bits",
            "format": "int32"
          }
        },
        "nullable": true
      },
      "CanopusPrediction": {
        "type": "object",
        "properties": {
          "classyFireClasses": {
            "type": "array",
            "description": "All predicted ClassyFire classes",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/CompoundClass"
            }
          },
          "npcClasses": {
            "type": "array",
            "description": "All predicted NPC classes",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/CompoundClass"
            }
          }
        },
        "description": "Container class that holds the CANOPUS compound class predictions for alle predictable compound classes.\n This is the full CANOPUS result.",
        "nullable": true
      },
      "Compound": {
        "type": "object",
        "properties": {
          "compoundId": {
            "type": "string",
            "description": "uid of this compound Entity"
          },
          "name": {
            "type": "string",
            "description": "Some (optional) human-readable name",
            "nullable": true
          },
          "rtStartSeconds": {
            "type": "number",
            "description": "The merged/consensus retention time start (earliest rt) of this compound",
            "format": "double",
            "nullable": true
          },
          "rtEndSeconds": {
            "type": "number",
            "description": "The merged/consensus retention time end (latest rt) of this compound",
            "format": "double",
            "nullable": true
          },
          "neutralMass": {
            "type": "number",
            "description": "Neutral mass of this compound. Ion masse minus the mass of the assigned adduct of each feature of\n this compound should result in the same neutral mass",
            "format": "double",
            "nullable": true
          },
          "features": {
            "type": "array",
            "description": "List of aligned features (adducts) that belong to the same (this) compound",
            "items": {
              "$ref": "#/components/schemas/AlignedFeature"
            }
          },
          "consensusAnnotations": {
            "$ref": "#/components/schemas/ConsensusAnnotationsCSI"
          },
          "consensusAnnotationsDeNovo": {
            "$ref": "#/components/schemas/ConsensusAnnotationsDeNovo"
          },
          "customAnnotations": {
            "$ref": "#/components/schemas/ConsensusAnnotationsCSI"
          },
          "tags": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/Tag"
            },
            "description": "Key: tagName, value: tag",
            "nullable": true
          }
        }
      },
      "CompoundClass": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/CompoundClassType"
          },
          "level": {
            "type": "string",
            "description": "Name of the level this compound class belongs to",
            "nullable": true
          },
          "levelIndex": {
            "type": "integer",
            "description": "Index of the level this compound class belongs to",
            "format": "int32",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Name of the compound class.",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "Description of the compound class.",
            "nullable": true
          },
          "id": {
            "type": "integer",
            "description": "Unique id of the class. Might be undefined for certain classification ontologies.",
            "format": "int32",
            "nullable": true
          },
          "probability": {
            "type": "number",
            "description": "prediction probability",
            "format": "double"
          },
          "index": {
            "type": "integer",
            "description": "Absolute index of this property in the predicted vector/embedding",
            "format": "int32"
          },
          "parentId": {
            "type": "integer",
            "description": "Unique id of the parent class. Might be undefined for certain classification ontologies.",
            "format": "int32",
            "nullable": true
          },
          "parentName": {
            "type": "string",
            "description": "Name of the parent compound class.",
            "nullable": true
          }
        },
        "description": "Predicted compound class with name, probability and id if available.\n (ClassyFire and NPC). This can be seen as the set of classes a feature most likely belongs to",
        "nullable": true
      },
      "CompoundClassType": {
        "type": "string",
        "description": "Defines compound class ontologies that are available.",
        "nullable": true,
        "enum": [
          "ClassyFire",
          "NPC"
        ]
      },
      "CompoundClasses": {
        "type": "object",
        "properties": {
          "npcPathway": {
            "$ref": "#/components/schemas/CompoundClass"
          },
          "npcSuperclass": {
            "$ref": "#/components/schemas/CompoundClass"
          },
          "npcClass": {
            "$ref": "#/components/schemas/CompoundClass"
          },
          "classyFireLineage": {
            "type": "array",
            "description": "Most likely ClassyFire lineage from ordered from least specific to most specific class\n classyFireLineage.get(classyFireLineage.size() - 1) gives the most specific ClassyFire compound class annotation",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/CompoundClass"
            }
          },
          "classyFireAlternatives": {
            "type": "array",
            "description": "Alternative ClassyFire classes with high probability that do not fit into the linage",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/CompoundClass"
            }
          }
        },
        "description": "Container class that holds the most likely compound class for different levels of each ontology for a\n certain Compound/Feature/FormulaCandidate/PredictedFingerprint.",
        "nullable": true
      },
      "ComputedSubtools": {
        "type": "object",
        "properties": {
          "librarySearch": {
            "type": "boolean"
          },
          "formulaSearch": {
            "type": "boolean"
          },
          "zodiac": {
            "type": "boolean"
          },
          "fingerprint": {
            "type": "boolean"
          },
          "canopus": {
            "type": "boolean"
          },
          "structureSearch": {
            "type": "boolean"
          },
          "deNovoSearch": {
            "type": "boolean"
          }
        },
        "description": "Specifies which tools have been executed for this feature. Can be used to estimate which results can be expected. Null if it was not requested und non-null otherwise.",
        "nullable": true
      },
      "ConsensusAnnotationsCSI": {
        "type": "object",
        "properties": {
          "molecularFormula": {
            "type": "string",
            "description": "Molecular formula of the consensus annotation\n Might be null if no consensus formula is available.",
            "nullable": true
          },
          "compoundClasses": {
            "$ref": "#/components/schemas/CompoundClasses"
          },
          "supportingFeatureIds": {
            "type": "array",
            "description": "FeatureIds where the topAnnotation supports this annotation.",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "selectionCriterion": {
            "$ref": "#/components/schemas/ConsensusCriterionCSI"
          },
          "csiFingerIdStructure": {
            "$ref": "#/components/schemas/StructureCandidate"
          },
          "confidenceExactMatch": {
            "type": "number",
            "description": "Confidence value that represents the certainty that reported consensus structure is exactly the measured one\n If multiple features support this consensus structure the maximum confidence is reported",
            "format": "double",
            "nullable": true
          },
          "confidenceApproxMatch": {
            "type": "number",
            "description": "Confidence value that represents the certainty that the exact consensus structure or a very similar\n structure (e.g. measured by Maximum Common Edge Subgraph Distance) is the measured one.\n If multiple features support this consensus structure the maximum confidence is reported",
            "format": "double",
            "nullable": true
          }
        },
        "nullable": true
      },
      "ConsensusAnnotationsDeNovo": {
        "type": "object",
        "properties": {
          "molecularFormula": {
            "type": "string",
            "description": "Molecular formula of the consensus annotation\n Might be null if no consensus formula is available.",
            "nullable": true
          },
          "compoundClasses": {
            "$ref": "#/components/schemas/CompoundClasses"
          },
          "supportingFeatureIds": {
            "type": "array",
            "description": "FeatureIds where the topAnnotation supports this annotation.",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "selectionCriterion": {
            "$ref": "#/components/schemas/ConsensusCriterionDeNovo"
          }
        },
        "nullable": true
      },
      "ConsensusCriterionCSI": {
        "type": "string",
        "nullable": true,
        "enum": [
          "MAJORITY_STRUCTURE",
          "CONFIDENCE_STRUCTURE",
          "SINGLETON_STRUCTURE",
          "MAJORITY_FORMULA",
          "TOP_FORMULA",
          "SINGLETON_FORMULA"
        ]
      },
      "ConsensusCriterionDeNovo": {
        "type": "string",
        "nullable": true,
        "enum": [
          "MAJORITY_FORMULA",
          "TOP_FORMULA",
          "SINGLETON_FORMULA"
        ]
      },
      "DBLink": {
        "required": [
          "name"
        ],
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "id": {
            "type": "string"
          }
        },
        "nullable": true
      },
      "Deviation": {
        "type": "object",
        "properties": {
          "ppm": {
            "type": "number",
            "format": "double"
          },
          "absolute": {
            "type": "number",
            "format": "double"
          }
        },
        "nullable": true
      },
      "FeatureAnnotations": {
        "type": "object",
        "properties": {
          "formulaAnnotation": {
            "$ref": "#/components/schemas/FormulaCandidate"
          },
          "structureAnnotation": {
            "$ref": "#/components/schemas/StructureCandidateScored"
          },
          "compoundClassAnnotation": {
            "$ref": "#/components/schemas/CompoundClasses"
          },
          "confidenceExactMatch": {
            "type": "number",
            "description": "Confidence Score that represents the confidence whether the top hit is correct.",
            "format": "double",
            "nullable": true
          },
          "confidenceApproxMatch": {
            "type": "number",
            "description": "Confidence Score that represents the confidence whether the top hit or a very similar hit (estimated by MCES distance) is correct.",
            "format": "double",
            "nullable": true
          },
          "expansiveSearchState": {
            "$ref": "#/components/schemas/ConfidenceMode"
          },
          "specifiedDatabases": {
            "type": "array",
            "description": "List of databases that have been specified by for structure db search. Null if no structure db search has been performed.",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "expandedDatabases": {
            "type": "array",
            "description": "List of databases that have been used to expand search space during expansive search. Null if no structure db search has been performed.",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          }
        },
        "description": "Summary of the results of a feature (aligned over runs). Can be added to a AlignedFeature.\n The different annotation fields within this summary object are null if the corresponding\n feature does not contain the represented results. If fields are non-null\n the corresponding result has been computed but might still be empty.",
        "nullable": true
      },
      "FormulaCandidate": {
        "type": "object",
        "properties": {
          "formulaId": {
            "type": "string",
            "description": "Unique identifier of this formula candidate"
          },
          "molecularFormula": {
            "type": "string",
            "description": "molecular formula of this formula candidate"
          },
          "adduct": {
            "type": "string",
            "description": "Adduct of this formula candidate"
          },
          "rank": {
            "type": "integer",
            "format": "int32"
          },
          "siriusScoreNormalized": {
            "type": "number",
            "description": "Normalized Sirius Score of the formula candidate.\n If NULL result is not available",
            "format": "double",
            "nullable": true
          },
          "siriusScore": {
            "type": "number",
            "description": "Sirius Score (isotope + tree score) of the formula candidate.\n If NULL result is not available",
            "format": "double",
            "nullable": true
          },
          "isotopeScore": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "treeScore": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "zodiacScore": {
            "type": "number",
            "description": "Zodiac Score of the formula candidate.\n If NULL result is not available",
            "format": "double",
            "nullable": true
          },
          "numOfExplainedPeaks": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "numOfExplainablePeaks": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "totalExplainedIntensity": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "medianMassDeviation": {
            "$ref": "#/components/schemas/Deviation"
          },
          "fragmentationTree": {
            "$ref": "#/components/schemas/FragmentationTree"
          },
          "annotatedSpectrum": {
            "$ref": "#/components/schemas/AnnotatedSpectrum"
          },
          "isotopePatternAnnotation": {
            "$ref": "#/components/schemas/IsotopePatternAnnotation"
          },
          "lipidAnnotation": {
            "$ref": "#/components/schemas/LipidAnnotation"
          },
          "predictedFingerprint": {
            "type": "array",
            "description": "Probabilistic molecular fingerprint predicted by CSI:FingerID",
            "nullable": true,
            "items": {
              "type": "number",
              "format": "double",
              "nullable": true
            }
          },
          "compoundClasses": {
            "$ref": "#/components/schemas/CompoundClasses"
          },
          "canopusPrediction": {
            "$ref": "#/components/schemas/CanopusPrediction"
          }
        },
        "description": "Molecular formula candidate that holds a unique identifier (molecular formula + adduct).\n It can be extended with optional scoring metrics and the raw results\n such as fragmentation trees and simulated isotope pattern.",
        "nullable": true
      },
      "FragmentNode": {
        "type": "object",
        "properties": {
          "fragmentId": {
            "type": "integer",
            "format": "int32"
          },
          "molecularFormula": {
            "type": "string",
            "description": "neutral molecular formula of the fragment without adduct",
            "nullable": true
          },
          "adduct": {
            "type": "string",
            "description": "This combines the ionization plus adduct of the fragment. In contrast to the {@link FragmentationTree FragmentationTree}s adduct,\n this adduct may not include any in-source loss.",
            "nullable": true
          },
          "massDeviationDa": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "massDeviationPpm": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "score": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "intensity": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "mz": {
            "type": "number",
            "format": "double",
            "nullable": true
          }
        }
      },
      "FragmentationTree": {
        "type": "object",
        "properties": {
          "fragments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FragmentNode"
            }
          },
          "losses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LossEdge"
            }
          },
          "treeScore": {
            "type": "number",
            "format": "double"
          },
          "molecularFormula": {
            "type": "string"
          },
          "adduct": {
            "type": "string"
          }
        },
        "description": "Simple and easy serializable fragmentation tree model with annotated fragments/nodes abd losses/edges\n Root fragment has index 0;\n Molecular formula and adduct are identical to the ones of the corresponding molecular formula candidate and SpectrumAnnotation",
        "nullable": true
      },
      "IsotopePatternAnnotation": {
        "type": "object",
        "properties": {
          "isotopePattern": {
            "$ref": "#/components/schemas/BasicSpectrum"
          },
          "simulatedPattern": {
            "$ref": "#/components/schemas/BasicSpectrum"
          }
        },
        "nullable": true
      },
      "LipidAnnotation": {
        "type": "object",
        "properties": {
          "lipidSpecies": {
            "type": "string",
            "description": "Predicted lipid species in LIPID MAPS notation.\n NULL if not classified as lipid.",
            "nullable": true
          },
          "lipidMapsId": {
            "type": "string",
            "description": "LIPID MAPS id of the predicted lipid class.",
            "nullable": true
          },
          "lipidClassName": {
            "type": "string",
            "description": "Human-readable name of the predicted lipid class.",
            "nullable": true
          },
          "hypotheticalStructure": {
            "type": "string",
            "description": "Hypothetical molecular structure of the predicted lipid species as SMILES.\n NULL if hypothetical structure not available.",
            "nullable": true
          },
          "chainsUnknown": {
            "type": "boolean",
            "description": "True of the formula composition of the chains could not be determined from the MS/MS.",
            "nullable": true
          }
        },
        "nullable": true
      },
      "LossEdge": {
        "type": "object",
        "properties": {
          "sourceFragmentIdx": {
            "type": "integer",
            "format": "int32"
          },
          "targetFragmentIdx": {
            "type": "integer",
            "format": "int32"
          },
          "molecularFormula": {
            "type": "string"
          },
          "score": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "MsData": {
        "type": "object",
        "properties": {
          "mergedMs1": {
            "$ref": "#/components/schemas/BasicSpectrum"
          },
          "mergedMs2": {
            "$ref": "#/components/schemas/BasicSpectrum"
          },
          "ms1Spectra": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BasicSpectrum"
            }
          },
          "ms2Spectra": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BasicSpectrum"
            }
          }
        },
        "description": "The MsData wraps all spectral input data belonging to a (aligned) feature. All spectra fields are optional.\n However, at least one Spectrum field needs to be set to create a valid MsData Object.\n The different types of spectra fields can be extended to adapt to other MassSpec measurement techniques not covered yet.\n \u003cp\u003e\n Each Feature can have:\n - One merged MS/MS spectrum (optional)\n - One merged MS spectrum (optional)\n - many MS/MS spectra (optional)\n - many MS spectra (optional)\n \u003cp\u003e\n Each non-merged spectrum has an index which can be used to access the spectrum.\n \u003cp\u003e\n In the future we might add some additional information like chromatographic peak or something similar",
        "nullable": true
      },
      "ParentPeak": {
        "required": [
          "lossFormula",
          "parentFragmentId",
          "parentIdx"
        ],
        "type": "object",
        "properties": {
          "parentIdx": {
            "type": "integer",
            "description": "Index to the parent peak connected by this loss in this particular spectrum",
            "format": "int32"
          },
          "parentFragmentId": {
            "type": "integer",
            "description": "Identifier of the parent fragment connected via this loss. Can be used to map fragments and peaks\n among fragmentation trees and spectra.",
            "format": "int32"
          },
          "lossFormula": {
            "type": "string",
            "description": "Molecular formula of the neutral loss that connects these two peaks."
          }
        },
        "description": "Link from annotated fragment peak to its parent fragment peak connected by their neutral loss.",
        "nullable": true
      },
      "PeakAnnotation": {
        "required": [
          "fragmentId"
        ],
        "type": "object",
        "properties": {
          "fragmentId": {
            "type": "integer",
            "description": "Identifier of the peak/fragment. Can be used to map fragments and peaks\n among fragmentation trees and spectra.",
            "format": "int32"
          },
          "molecularFormula": {
            "type": "string",
            "description": "Molecular formula that has been annotated to this peak",
            "nullable": true
          },
          "adduct": {
            "type": "string",
            "description": "Adduct that has been annotated to this peak",
            "nullable": true
          },
          "exactMass": {
            "type": "number",
            "description": "Exact mass of the annotated molecular formula and adduct",
            "format": "double",
            "nullable": true
          },
          "massDeviationMz": {
            "type": "number",
            "description": "Absolute mass deviation of the exact mass to the measured peak mass in mDa",
            "format": "double",
            "nullable": true
          },
          "massDeviationPpm": {
            "type": "number",
            "description": "Relative mass deviation of the exact mass to the measured peak mass in ppm",
            "format": "double",
            "nullable": true
          },
          "recalibratedMassDeviationMz": {
            "type": "number",
            "description": "Absolute mass deviation of the exact mass to the recalibrated peak mass in mDa",
            "format": "double",
            "nullable": true
          },
          "recalibratedMassDeviationPpm": {
            "type": "number",
            "description": "Relative mass deviation of the exact mass to the recalibrated peak mass in ppm",
            "format": "double",
            "nullable": true
          },
          "parentPeak": {
            "$ref": "#/components/schemas/ParentPeak"
          },
          "substructureAtoms": {
            "type": "array",
            "description": "EXPERIMENTAL: This field is experimental and may be changed (or even removed) without notice until it is declared stable.\n\n Array/List of indices of the atoms of the structure candidate that are part of this fragments substructure\n (highlighted atoms)",
            "nullable": true,
            "items": {
              "type": "integer",
              "format": "int32",
              "nullable": true
            }
          },
          "substructureBonds": {
            "type": "array",
            "description": "EXPERIMENTAL: This field is experimental and may be changed (or even removed) without notice until it is declared stable.\n\n Array/List of indices of the bonds of the structure candidate that are part of this fragments substructure\n (highlighted bonds)\n\n Null if substructure annotation not available or not requested.",
            "nullable": true,
            "items": {
              "type": "integer",
              "format": "int32",
              "nullable": true
            }
          },
          "substructureBondsCut": {
            "type": "array",
            "description": "EXPERIMENTAL: This field is experimental and may be changed (or even removed) without notice until it is declared stable.\n\n Array/List of indices of the bonds of the structure candidate that need to be cut to produce this fragments\n substructure (highlighted cutted bonds).\n\n Null if substructure annotation not available or not requested.",
            "nullable": true,
            "items": {
              "type": "integer",
              "format": "int32",
              "nullable": true
            }
          },
          "substructureScore": {
            "type": "number",
            "description": "EXPERIMENTAL: This field is experimental and may be changed (or even removed) without notice until it is declared stable.\n\n This score roughly reflects the probability of this fragment forming.\n\n This is the score of the path from root to this node which has the maximal score or \"profit\".\n The score of a path is equal to the sum of scores of its contained fragments and edges.\n Note: Refers to \u0027totalScore\u0027 in CombinatorialNode\n\n Null if substructure annotation not available or not requested.",
            "format": "float",
            "nullable": true
          },
          "hydrogenRearrangements": {
            "type": "integer",
            "description": "EXPERIMENTAL: This field is experimental and may be changed (or even removed) without notice until it is declared stable.\n\n Number of hydrogens rearrangements needed to match the substructure to the fragment formula.\n\n Null if substructure annotation not available or not requested.",
            "format": "int32",
            "nullable": true
          }
        },
        "nullable": true
      },
      "PeakPair": {
        "required": [
          "queryPeak",
          "referencePeak"
        ],
        "type": "object",
        "properties": {
          "queryPeak": {
            "type": "integer",
            "format": "int32"
          },
          "referencePeak": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "SpectralLibraryMatch": {
        "required": [
          "inchiKey",
          "querySpectrumIndex",
          "similarity",
          "uuid"
        ],
        "type": "object",
        "properties": {
          "specMatchId": {
            "type": "string"
          },
          "rank": {
            "type": "integer",
            "format": "int32"
          },
          "similarity": {
            "type": "number",
            "description": "Similarity between query and reference spectrum",
            "format": "float"
          },
          "sharedPeaks": {
            "type": "integer",
            "description": "Number of shared/matched peaks",
            "format": "int32"
          },
          "sharedPeakMapping": {
            "type": "array",
            "description": "List of paired/matched peak indices.\n\n Maps indices of peaks from the query spectrum (mass sorted)\n to indices of matched peaks in the reference spectrum (mass sorted)",
            "items": {
              "$ref": "#/components/schemas/PeakPair"
            }
          },
          "querySpectrumIndex": {
            "type": "integer",
            "format": "int32"
          },
          "dbName": {
            "type": "string"
          },
          "dbId": {
            "type": "string"
          },
          "uuid": {
            "type": "integer",
            "format": "int64"
          },
          "splash": {
            "type": "string"
          },
          "molecularFormula": {
            "type": "string"
          },
          "adduct": {
            "type": "string"
          },
          "exactMass": {
            "type": "number",
            "format": "double"
          },
          "smiles": {
            "type": "string"
          },
          "type": {
            "$ref": "#/components/schemas/SpectralMatchType"
          },
          "inchiKey": {
            "type": "string"
          },
          "referenceSpectrumType": {
            "$ref": "#/components/schemas/SpectrumType"
          },
          "referenceSpectrum": {
            "$ref": "#/components/schemas/BasicSpectrum"
          },
          "querySpectrumType": {
            "$ref": "#/components/schemas/SpectrumType"
          }
        },
        "nullable": true
      },
      "SpectralMatchType": {
        "type": "string",
        "default": "IDENTITY",
        "enum": [
          "IDENTITY",
          "ANALOG"
        ]
      },
      "SpectrumAnnotation": {
        "type": "object",
        "properties": {
          "molecularFormula": {
            "type": "string",
            "description": "Molecular formula that has been annotated to this spectrum",
            "nullable": true
          },
          "adduct": {
            "type": "string",
            "description": "Adduct that has been annotated to this spectrum",
            "nullable": true
          },
          "exactMass": {
            "type": "number",
            "description": "Exact mass based on the annotated molecular formula and ionization",
            "format": "double",
            "nullable": true
          },
          "massDeviationMz": {
            "type": "number",
            "description": "Absolute mass deviation of the exact mass to the precursor mass (precursorMz) of this spectrum in mDa",
            "format": "double",
            "nullable": true
          },
          "massDeviationPpm": {
            "type": "number",
            "description": "Relative mass deviation of the exact mass to the precursor mass (precursorMz) of this spectrum in ppm",
            "format": "double",
            "nullable": true
          },
          "structureAnnotationSmiles": {
            "type": "string",
            "description": "EXPERIMENTAL: This field is experimental and may be changed (or even removed) without notice until it is declared stable.\n \u003cp\u003e\n Smiles of the structure candidate used to derive substructure peak annotations via epimetheus insilico fragmentation\n Substructure highlighting (bond and atom indices) refer to this specific SMILES.\n If you standardize or canonicalize this SMILES in any way the indices of substructure highlighting might\n not match correctly anymore.\n \u003cp\u003e\n Null if substructure annotation not available or not requested.",
            "nullable": true
          },
          "structureAnnotationSvg": {
            "type": "string",
            "description": "EXPERIMENTAL: This field is experimental and may be changed (or even removed) without notice until it is declared stable.\n \u003cp\u003e\n SVG graphics of the structure candidate used to derive substructure peak annotations via epimetheus insilico fragmentation\n Substructure highlighting (bond and atom indices) refers to this SVG.\n \u003cp\u003e\n Null if substructure annotation not available or not requested.",
            "nullable": true
          },
          "structureAnnotationScore": {
            "type": "number",
            "description": "EXPERIMENTAL: This field is experimental and may be changed (or even removed) without notice until it is declared stable.\n \u003cp\u003e\n Overall score of all substructure annotations computed for this structure candidate (structureAnnotationSmiles)\n \u003cp\u003e\n Null if substructure annotation not available or not requested.",
            "format": "double",
            "nullable": true
          }
        },
        "nullable": true
      },
      "SpectrumType": {
        "type": "string",
        "enum": [
          "SPECTRUM",
          "MERGED_SPECTRUM"
        ]
      },
      "StructureCandidate": {
        "type": "object",
        "properties": {
          "inchiKey": {
            "type": "string"
          },
          "smiles": {
            "type": "string"
          },
          "structureName": {
            "type": "string",
            "nullable": true
          },
          "xlogP": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "dbLinks": {
            "type": "array",
            "description": "List of structure database links belonging to this structure candidate\n OPTIONAL: needs to be added by parameter",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/DBLink"
            }
          },
          "spectralLibraryMatches": {
            "type": "array",
            "description": "List of spectral library matches belonging to this structure candidate\n OPTIONAL: needs to be added by parameter",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/SpectralLibraryMatch"
            }
          }
        },
        "nullable": true
      },
      "StructureCandidateScored": {
        "type": "object",
        "properties": {
          "inchiKey": {
            "type": "string"
          },
          "smiles": {
            "type": "string"
          },
          "structureName": {
            "type": "string",
            "nullable": true
          },
          "xlogP": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "dbLinks": {
            "type": "array",
            "description": "List of structure database links belonging to this structure candidate\n OPTIONAL: needs to be added by parameter",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/DBLink"
            }
          },
          "spectralLibraryMatches": {
            "type": "array",
            "description": "List of spectral library matches belonging to this structure candidate\n OPTIONAL: needs to be added by parameter",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/SpectralLibraryMatch"
            }
          },
          "rank": {
            "type": "integer",
            "description": "the overall rank of this candidate among all candidates of this feature",
            "format": "int32"
          },
          "csiScore": {
            "type": "number",
            "description": "CSI:FingerID score of the fingerprint of this compound to the predicted fingerprint of CSI:FingerID\n This is the score used for ranking structure candidates",
            "format": "double"
          },
          "tanimotoSimilarity": {
            "type": "number",
            "description": "Tanimoto similarly of the fingerprint of this compound to the predicted fingerprint of CSI:FingerID",
            "format": "double",
            "nullable": true
          },
          "mcesDistToTopHit": {
            "type": "number",
            "description": "Maximum Common Edge Subgraph (MCES) distance to the top scoring hit (CSI:FingerID) in a candidate list.",
            "format": "double",
            "nullable": true
          },
          "fingerprint": {
            "$ref": "#/components/schemas/BinaryFingerprint"
          }
        },
        "nullable": true
      },
      "StoredJobSubmission": {
        "required": [
          "editable",
          "jobSubmission",
          "name"
        ],
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Unique name to identify this JobSubmission (job config)."
          },
          "editable": {
            "type": "boolean",
            "description": "False for predefined configs which are not editable and not removable."
          },
          "jobSubmission": {
            "$ref": "#/components/schemas/JobSubmission"
          }
        }
      },
      "AccountCredentials": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "nullable": true
          },
          "password": {
            "type": "string",
            "nullable": true
          },
          "refreshToken": {
            "type": "string",
            "nullable": true
          }
        },
        "description": "Simple object to hold account credentials, e.g. to perform login operations.\n If refreshToken is given, it is usually preferred over password based authentication.\n But in the end this is up to the respective web service."
      },
      "RunOptField": {
        "type": "string",
        "nullable": true,
        "enum": [
          "none",
          "tags"
        ]
      },
      "Run": {
        "type": "object",
        "properties": {
          "runId": {
            "type": "string",
            "description": "Identifier"
          },
          "name": {
            "type": "string",
            "description": "Informative, human-readable name of this run"
          },
          "source": {
            "type": "string",
            "description": "Source location"
          },
          "chromatography": {
            "type": "string",
            "nullable": true
          },
          "ionization": {
            "type": "string",
            "nullable": true
          },
          "fragmentation": {
            "type": "string",
            "nullable": true
          },
          "massAnalyzers": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "tags": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/Tag"
            },
            "description": "Key: tagName, value: tag",
            "nullable": true
          }
        }
      },
      "PageMetadata": {
        "type": "object",
        "properties": {
          "size": {
            "type": "integer",
            "format": "int64"
          },
          "number": {
            "type": "integer",
            "format": "int64"
          },
          "totalElements": {
            "type": "integer",
            "format": "int64"
          },
          "totalPages": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "PagedModelRun": {
        "type": "object",
        "properties": {
          "content": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Run"
            }
          },
          "page": {
            "$ref": "#/components/schemas/PageMetadata"
          }
        }
      },
      "PagedModelJob": {
        "type": "object",
        "properties": {
          "content": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Job"
            }
          },
          "page": {
            "$ref": "#/components/schemas/PageMetadata"
          }
        }
      },
      "AdductEdgeExperimental": {
        "type": "object",
        "properties": {
          "mzDelta": {
            "type": "number",
            "format": "double"
          },
          "annotation": {
            "type": "string"
          },
          "from": {
            "type": "integer",
            "format": "int32"
          },
          "to": {
            "type": "integer",
            "format": "int32"
          },
          "mergedCorrelation": {
            "type": "number",
            "format": "float"
          },
          "representativeCorrelation": {
            "type": "number",
            "format": "float"
          },
          "ms2cosine": {
            "type": "number",
            "format": "float"
          },
          "pvalue": {
            "type": "number",
            "format": "float"
          },
          "intensityRatioScore": {
            "type": "number",
            "format": "float"
          }
        },
        "description": "EXPERIMENTAL: This schema is experimental and may be changed (or even removed) without notice until it is declared stable."
      },
      "AdductNetworkExperimental": {
        "type": "object",
        "properties": {
          "nodes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AdductNodeExperimental"
            }
          },
          "edges": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AdductEdgeExperimental"
            }
          }
        },
        "description": "EXPERIMENTAL: This schema is experimental and may be changed (or even removed) without notice until it is declared stable."
      },
      "AdductNodeExperimental": {
        "type": "object",
        "properties": {
          "alignedFeatureId": {
            "type": "string"
          },
          "mz": {
            "type": "number",
            "format": "double"
          },
          "adductAnnotations": {
            "type": "object",
            "additionalProperties": {
              "type": "number",
              "format": "double"
            }
          }
        },
        "description": "EXPERIMENTAL: This schema is experimental and may be changed (or even removed) without notice until it is declared stable."
      },
      "Axes": {
        "type": "object",
        "properties": {
          "scanNumber": {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int32"
            }
          },
          "scanIds": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "retentionTimeInSeconds": {
            "type": "array",
            "items": {
              "type": "number",
              "format": "double"
            }
          }
        }
      },
      "TraceAnnotationExperimental": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/TraceAnnotationTypeExperimental"
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "index": {
            "type": "integer",
            "format": "int32"
          },
          "from": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "to": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          }
        },
        "description": "EXPERIMENTAL: This schema is experimental and may be changed (or even removed) without notice until it is declared stable."
      },
      "TraceAnnotationTypeExperimental": {
        "type": "string",
        "description": "EXPERIMENTAL: This schema is experimental and may be changed (or even removed) without notice until it is declared stable.",
        "enum": [
          "FEATURE",
          "MS2"
        ]
      },
      "TraceExperimental": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "sampleId": {
            "type": "string",
            "nullable": true
          },
          "sampleName": {
            "type": "string",
            "nullable": true
          },
          "label": {
            "type": "string"
          },
          "intensities": {
            "type": "array",
            "items": {
              "type": "number",
              "format": "double"
            }
          },
          "annotations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TraceAnnotationExperimental"
            }
          },
          "mz": {
            "type": "number",
            "format": "double"
          },
          "merged": {
            "type": "boolean"
          },
          "normalizationFactor": {
            "type": "number",
            "description": "Traces are stored with raw intensity values. The normalization factor maps them to relative intensities,\n such that traces from different samples can be compared.",
            "format": "double"
          },
          "noiseLevel": {
            "type": "number",
            "description": "The noise level is estimated from the median noise in the surrounding scans. It can be used to\n calculate signal-to-noise ratios.",
            "format": "double"
          }
        },
        "description": "EXPERIMENTAL: This schema is experimental and may be changed (or even removed) without notice until it is declared stable."
      },
      "TraceSetExperimental": {
        "type": "object",
        "properties": {
          "adductNetwork": {
            "$ref": "#/components/schemas/AdductNetworkExperimental"
          },
          "sampleId": {
            "type": "string"
          },
          "sampleName": {
            "type": "string"
          },
          "axes": {
            "$ref": "#/components/schemas/Axes"
          },
          "traces": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TraceExperimental"
            }
          }
        },
        "description": "EXPERIMENTAL: This schema is experimental and may be changed (or even removed) without notice until it is declared stable."
      },
      "QuantRowType": {
        "type": "string",
        "enum": [
          "FEATURES",
          "COMPOUNDS"
        ]
      },
      "QuantTableExperimental": {
        "type": "object",
        "properties": {
          "quantificationMeasure": {
            "$ref": "#/components/schemas/QuantMeasure"
          },
          "rowType": {
            "$ref": "#/components/schemas/QuantRowType"
          },
          "rowIds": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "integer",
              "format": "int64",
              "nullable": true
            }
          },
          "columnIds": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "integer",
              "format": "int64",
              "nullable": true
            }
          },
          "rowNames": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "columnNames": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "string",
              "nullable": true
            }
          },
          "values": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "double"
              }
            }
          }
        },
        "description": "EXPERIMENTAL: This schema is experimental and may be changed (or even removed) without notice until it is declared stable."
      },
      "PagedModelCompound": {
        "type": "object",
        "properties": {
          "content": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Compound"
            }
          },
          "page": {
            "$ref": "#/components/schemas/PageMetadata"
          }
        }
      },
      "FoldChange": {
        "required": [
          "foldChange",
          "objectId",
          "quantType"
        ],
        "type": "object",
        "properties": {
          "leftGroup": {
            "type": "string"
          },
          "rightGroup": {
            "type": "string"
          },
          "aggregation": {
            "$ref": "#/components/schemas/AggregationType"
          },
          "quantification": {
            "$ref": "#/components/schemas/QuantMeasure"
          },
          "quantType": {
            "$ref": "#/components/schemas/QuantRowType"
          },
          "objectId": {
            "type": "string"
          },
          "foldChange": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "StatisticsTable": {
        "type": "object",
        "properties": {
          "statisticsType": {
            "$ref": "#/components/schemas/StatisticsType"
          },
          "aggregationType": {
            "$ref": "#/components/schemas/AggregationType"
          },
          "quantificationMeasure": {
            "$ref": "#/components/schemas/QuantMeasure"
          },
          "rowType": {
            "$ref": "#/components/schemas/QuantRowType"
          },
          "rowIds": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "columnNames": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "columnLeftGroups": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "columnRightGroups": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "values": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "double"
              }
            }
          }
        }
      },
      "StatisticsType": {
        "type": "string",
        "enum": [
          "FOLD_CHANGE"
        ]
      },
      "SpectralLibraryMatchOptField": {
        "type": "string",
        "nullable": true,
        "enum": [
          "none",
          "referenceSpectrum"
        ]
      },
      "SpectralLibraryMatchSummary": {
        "required": [
          "databaseCompoundCount",
          "referenceSpectraCount",
          "spectralMatchCount"
        ],
        "type": "object",
        "properties": {
          "bestMatch": {
            "$ref": "#/components/schemas/SpectralLibraryMatch"
          },
          "spectralMatchCount": {
            "type": "integer",
            "format": "int64"
          },
          "referenceSpectraCount": {
            "type": "integer",
            "format": "int32"
          },
          "databaseCompoundCount": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "PagedModelSpectralLibraryMatch": {
        "type": "object",
        "properties": {
          "content": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SpectralLibraryMatch"
            }
          },
          "page": {
            "$ref": "#/components/schemas/PageMetadata"
          }
        }
      },
      "AlignedFeatureQualityExperimental": {
        "required": [
          "alignedFeatureId",
          "categories",
          "overallQuality"
        ],
        "type": "object",
        "properties": {
          "alignedFeatureId": {
            "type": "string",
            "description": "Id of the feature (aligned over runs) this quality information belongs to."
          },
          "overallQuality": {
            "$ref": "#/components/schemas/DataQuality"
          },
          "categories": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/Category"
            },
            "description": "Contains all pre-computation quality information that belong to\n this feature (aligned over runs), such as information about the quality of the peak shape, MS2 spectrum etc.,"
          }
        },
        "description": "EXPERIMENTAL: This schema is experimental and may be changed (or even removed) without notice until it is declared stable."
      },
      "Category": {
        "type": "object",
        "properties": {
          "categoryName": {
            "type": "string"
          },
          "overallQuality": {
            "$ref": "#/components/schemas/DataQuality"
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QualityItem"
            }
          }
        }
      },
      "QualityItem": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          },
          "quality": {
            "$ref": "#/components/schemas/DataQuality"
          },
          "weight": {
            "$ref": "#/components/schemas/QualityWeight"
          }
        }
      },
      "QualityWeight": {
        "type": "string",
        "enum": [
          "MINOR",
          "MAJOR",
          "CRITICAL"
        ]
      },
      "FormulaCandidateOptField": {
        "type": "string",
        "nullable": true,
        "enum": [
          "none",
          "statistics",
          "fragmentationTree",
          "annotatedSpectrum",
          "isotopePattern",
          "lipidAnnotation",
          "predictedFingerprint",
          "compoundClasses",
          "canopusPredictions"
        ]
      },
      "AnnotatedMsMsData": {
        "required": [
          "mergedMs2",
          "ms2Spectra"
        ],
        "type": "object",
        "properties": {
          "mergedMs2": {
            "$ref": "#/components/schemas/AnnotatedSpectrum"
          },
          "ms2Spectra": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AnnotatedSpectrum"
            }
          }
        }
      },
      "StructureCandidateOptField": {
        "type": "string",
        "nullable": true,
        "enum": [
          "none",
          "fingerprint",
          "dbLinks",
          "libraryMatches"
        ]
      },
      "PagedModelStructureCandidateScored": {
        "type": "object",
        "properties": {
          "content": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StructureCandidateScored"
            }
          },
          "page": {
            "$ref": "#/components/schemas/PageMetadata"
          }
        }
      },
      "PagedModelFormulaCandidate": {
        "type": "object",
        "properties": {
          "content": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FormulaCandidate"
            }
          },
          "page": {
            "$ref": "#/components/schemas/PageMetadata"
          }
        }
      },
      "StructureCandidateFormula": {
        "type": "object",
        "properties": {
          "inchiKey": {
            "type": "string"
          },
          "smiles": {
            "type": "string"
          },
          "structureName": {
            "type": "string",
            "nullable": true
          },
          "xlogP": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "dbLinks": {
            "type": "array",
            "description": "List of structure database links belonging to this structure candidate\n OPTIONAL: needs to be added by parameter",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/DBLink"
            }
          },
          "spectralLibraryMatches": {
            "type": "array",
            "description": "List of spectral library matches belonging to this structure candidate\n OPTIONAL: needs to be added by parameter",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/SpectralLibraryMatch"
            }
          },
          "rank": {
            "type": "integer",
            "description": "the overall rank of this candidate among all candidates of this feature",
            "format": "int32"
          },
          "csiScore": {
            "type": "number",
            "description": "CSI:FingerID score of the fingerprint of this compound to the predicted fingerprint of CSI:FingerID\n This is the score used for ranking structure candidates",
            "format": "double"
          },
          "tanimotoSimilarity": {
            "type": "number",
            "description": "Tanimoto similarly of the fingerprint of this compound to the predicted fingerprint of CSI:FingerID",
            "format": "double",
            "nullable": true
          },
          "mcesDistToTopHit": {
            "type": "number",
            "description": "Maximum Common Edge Subgraph (MCES) distance to the top scoring hit (CSI:FingerID) in a candidate list.",
            "format": "double",
            "nullable": true
          },
          "fingerprint": {
            "$ref": "#/components/schemas/BinaryFingerprint"
          },
          "molecularFormula": {
            "type": "string",
            "description": "Molecular formula of this candidate"
          },
          "adduct": {
            "type": "string",
            "description": "Adduct of this candidate"
          },
          "formulaId": {
            "type": "string",
            "description": "Id of the corresponding Formula candidate"
          }
        }
      },
      "PagedModelStructureCandidateFormula": {
        "type": "object",
        "properties": {
          "content": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StructureCandidateFormula"
            }
          },
          "page": {
            "$ref": "#/components/schemas/PageMetadata"
          }
        }
      },
      "PagedModelAlignedFeature": {
        "type": "object",
        "properties": {
          "content": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AlignedFeature"
            }
          },
          "page": {
            "$ref": "#/components/schemas/PageMetadata"
          }
        }
      },
      "Info": {
        "required": [
          "availableILPSolvers",
          "supportedILPSolvers"
        ],
        "type": "object",
        "properties": {
          "nightSkyApiVersion": {
            "type": "string",
            "description": "API version of the SIRIUS Nightsky API",
            "nullable": true
          },
          "siriusVersion": {
            "type": "string",
            "description": "Version of the SIRIUS application",
            "nullable": true
          },
          "latestSiriusVersion": {
            "type": "string",
            "description": "Latest available Version of the SIRIUS application",
            "nullable": true
          },
          "latestSiriusLink": {
            "type": "string",
            "description": "Link to the latest available Version of the SIRIUS application",
            "nullable": true
          },
          "updateAvailable": {
            "type": "boolean",
            "description": "true if newer SIRIUS version is available"
          },
          "siriusLibVersion": {
            "type": "string",
            "description": "Version of the SIRIUS libraries",
            "nullable": true
          },
          "fingerIdLibVersion": {
            "type": "string",
            "description": "Version of the CSI:FingerID libraries",
            "nullable": true
          },
          "chemDbVersion": {
            "type": "string",
            "description": "Version of the Chemical Database available via SIRIUS web services",
            "nullable": true
          },
          "fingerIdModelVersion": {
            "type": "string",
            "description": "Version of the Machine learning models used for Fingerprint, Compound Class and Structure Prediction\n Not available if web service is not reachable.",
            "nullable": true
          },
          "fingerprintId": {
            "type": "string",
            "description": "Version of the Molecular Fingerprint used by SIRIUS",
            "nullable": true
          },
          "availableILPSolvers": {
            "type": "array",
            "description": "Set of solvers that are configured correctly and can be loaded",
            "items": {
              "$ref": "#/components/schemas/Solver"
            }
          },
          "supportedILPSolvers": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Set of ILP Solvers that are Supported and their version information"
          }
        }
      },
      "Solver": {
        "type": "string",
        "enum": [
          "GUROBI",
          "CPLEX",
          "GLPK",
          "CLP"
        ]
      },
      "GuiInfo": {
        "type": "object",
        "properties": {
          "projectId": {
            "type": "string",
            "description": "The project this instance is running on"
          }
        }
      },
      "ConnectionCheck": {
        "required": [
          "errors",
          "licenseInfo"
        ],
        "type": "object",
        "properties": {
          "licenseInfo": {
            "$ref": "#/components/schemas/LicenseInfo"
          },
          "errors": {
            "type": "array",
            "description": "List of errors ordered by significance. first error should be reported and addressed first.\n Following errors might just be follow-up errors",
            "items": {
              "$ref": "#/components/schemas/ConnectionError"
            }
          }
        }
      },
      "ConnectionError": {
        "required": [
          "errorKlass",
          "errorType",
          "siriusErrorCode",
          "siriusMessage"
        ],
        "type": "object",
        "properties": {
          "errorType": {
            "$ref": "#/components/schemas/ConnectionErrorType"
          },
          "errorKlass": {
            "$ref": "#/components/schemas/ConnectionErrorClass"
          },
          "siriusErrorCode": {
            "type": "integer",
            "format": "int32"
          },
          "siriusMessage": {
            "type": "string"
          },
          "serverResponseErrorCode": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "serverResponseErrorMessage": {
            "type": "string",
            "nullable": true
          },
          "error": {
            "type": "boolean"
          },
          "warning": {
            "type": "boolean"
          }
        }
      },
      "ConnectionErrorClass": {
        "type": "string",
        "enum": [
          "UNKNOWN",
          "INTERNET",
          "LOGIN_SERVER",
          "LICENSE_SERVER",
          "TOKEN",
          "LOGIN",
          "LICENSE",
          "TERMS",
          "APP_SERVER"
        ]
      },
      "ConnectionErrorType": {
        "type": "string",
        "enum": [
          "WARNING",
          "ERROR"
        ]
      },
      "LicenseInfo": {
        "type": "object",
        "properties": {
          "userEmail": {
            "type": "string",
            "description": "Email address of the user account this license information belongs to.",
            "nullable": true
          },
          "userId": {
            "type": "string",
            "description": "User ID (uid) of the user account this license information belongs to.",
            "nullable": true
          },
          "subscription": {
            "$ref": "#/components/schemas/Subscription"
          },
          "consumables": {
            "$ref": "#/components/schemas/SubscriptionConsumables"
          },
          "terms": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/Term"
            }
          }
        }
      },
      "SubscriptionConsumables": {
        "type": "object",
        "properties": {
          "pendingJobs": {
            "type": "integer",
            "format": "int32"
          },
          "countedCompounds": {
            "type": "integer",
            "format": "int32"
          }
        },
        "nullable": true
      },
      "Term": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "link": {
            "type": "string",
            "format": "uri"
          }
        },
        "nullable": true
      }
    }
  }
}